{"version":3,"file":"lib_index_js.a07fcb4825cec710f3c1.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACuC;AAC+B;AACd;AACO;AACI;AACN;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAe,EAAE,kEAAgB,EAAE,yEAAgB;AAClE;AACA;AACA;AACA;AACA,iFAAiF,UAAU;AAC3F;AACA;AACA,0CAA0C,IAAI,GAAG,IAAI;AACrD;AACA,yCAAyC,IAAI,GAAG,KAAK;AACrD,+BAA+B,0EAAc,kBAAkB,6DAAK;AACpE,oBAAoB,2EAAe,4BAA4B,UAAU;AACzE,iBAAiB;AACjB,aAAa;AACb,8BAA8B,gCAAgC;AAC9D;AACA;AACA,8BAA8B,IAAI,UAAU,IAAI;AAChD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,0EAAc,kBAAkB,6DAAK;AAChE,gBAAgB,2EAAe;AAC/B,aAAa;AACb,SAAS;AACT,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,QAAQ;AAChG;AACA,qBAAqB,gFAAgF,IAAI;AACzG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAI,GAAG,wBAAwB;AACxD;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,SAAS;AACpC,SAAS;AACT,uBAAuB,mBAAmB;AAC1C,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,2BAA2B,+DAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://jupyterlab-gridwidth/./lib/index.js"],"sourcesContent":["/*\n * for attaching keybindings later on, see\n * https://towardsdatascience.com/how-to-customize-jupyterlab-keyboard-shortcuts-72321f73753d\n */\n/* eslint-disable prettier/prettier */\nimport { Menu } from '@lumino/widgets';\nimport { ICommandPalette, ToolbarButton } from '@jupyterlab/apputils';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { Scope, apply_on_cells } from 'jupyterlab-celltagsclasses';\nimport { md_toggle_multi } from 'jupyterlab-celltagsclasses';\nconst PLUGIN_ID = 'jupyterlab-gridwidth:plugin';\nconst ALL_GRIDWIDTHS = [\n    '1-2',\n    '1-3',\n    '2-3',\n    '1-4',\n    '2-4',\n    '3-4',\n    '1-5',\n    '2-5',\n    '3-5',\n    '4-5',\n    '1-6',\n    '2-6',\n    '3-6',\n    '4-6',\n    '5-6',\n];\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    requires: [ICommandPalette, INotebookTracker, ISettingRegistry],\n    activate: (app, palette, notebookTracker, settingRegistry) => {\n        console.log('extension jupyterlab-gridwidth is activating');\n        let command;\n        // gridwidth-1-2..gridwidth-1-6\n        const ALL_GRIDWIDTHS_FULL = ALL_GRIDWIDTHS.map(gridwidth => `gridwidth-${gridwidth}`);\n        for (const gridwidth of ALL_GRIDWIDTHS) {\n            const [num, den] = gridwidth.split('-');\n            command = `gridwidth:toggle-${num}-${den}`;\n            app.commands.addCommand(command, {\n                label: `Toogle Cell to ${num}/${den} of Full Width`,\n                execute: () => apply_on_cells(notebookTracker, Scope.Multiple, (cell) => {\n                    md_toggle_multi(cell, 'tags', `gridwidth-${gridwidth}`, ALL_GRIDWIDTHS_FULL);\n                })\n            });\n            palette.addItem({ command, category: 'gridwidth' });\n            app.commands.addKeyBinding({\n                command,\n                keys: [`Alt ${num}`, `Alt ${den}`],\n                selector: '.jp-Notebook'\n            });\n        }\n        // a shortcut to cancel all gridwidths\n        command = 'gridwidth:cancel';\n        app.commands.addCommand(command, {\n            label: 'Restore Full Cell Width',\n            execute: () => apply_on_cells(notebookTracker, Scope.Multiple, (cell) => {\n                md_toggle_multi(cell, 'tags', '', ALL_GRIDWIDTHS_FULL);\n            })\n        });\n        palette.addItem({ command, category: 'gridwidth' });\n        app.commands.addKeyBinding({\n            command,\n            keys: ['Alt 0'],\n            selector: '.jp-Notebook'\n        });\n        notebookTracker.widgetAdded.connect((tracker, panel) => {\n            let button;\n            function loadSetting(setting) {\n                // Read the settings and convert to the correct type\n                const show_toolbar_button = setting.get('show_toolbar_button')\n                    .composite;\n                // actually this is typed as MenuBar\n                const menubar = panel.toolbar;\n                if (show_toolbar_button) {\n                    if (button) {\n                        console.debug('gridwidth: button already on');\n                        return;\n                    }\n                    console.debug('gridwidth: adding button', panel.content.node);\n                    button = new CellWidthMenu(app, tracker).button;\n                    menubar.insertItem(10, 'gridWidth', button);\n                }\n                else {\n                    if (button === undefined) {\n                        console.debug('gridwidth: button already off');\n                        return;\n                    }\n                    console.debug('gridwidth: disposing button', panel.content.node);\n                    button.dispose();\n                    button = undefined;\n                }\n                const windowing_mode_defer = setting.get('windowing_mode_defer')\n                    .composite;\n                if (windowing_mode_defer) {\n                    // force notebook windowing-mode to 'defer'\n                    // will be done - or not, depending on turn_off_windowing_mode\n                    // once our settings are loaded\n                    settingRegistry.load('@jupyterlab/notebook-extension:tracker').then((nbSettings) => {\n                        const former = nbSettings.get('windowingMode').composite;\n                        if (former === 'full') {\n                            nbSettings.set('windowingMode', 'defer'),\n                                console.warn('jupyterlab-gridwidth: windowing mode FORCED back to \"defer\"');\n                        }\n                        else {\n                            console.log(`jupyterlab-gridwidth: windowing mode already ${former} - unchanged`);\n                        }\n                    }, (err) => console.error(`jupyterlab-gridwidth: Could not set windowing mode: ${err}`));\n                }\n            }\n            Promise.all([app.restored, settingRegistry.load(PLUGIN_ID)]).then(([_, setting]) => {\n                loadSetting(setting);\n                setting.changed.connect(loadSetting);\n            });\n        });\n    }\n};\n// a lumino menu & a toolbar button to invoke the menu\nclass CellWidthMenu {\n    constructor(app, notebookTracker) {\n        this.menuOpen = false;\n        this.preventOpen = false;\n        this.button = this.createButton(app, notebookTracker);\n    }\n    createButton(app, notebookTracker) {\n        // create a lumino menu\n        const menu = new Menu({ commands: app.commands });\n        menu.title.label = 'Cell Width';\n        ALL_GRIDWIDTHS.forEach(gridwidth => {\n            const command = `gridwidth:toggle-${gridwidth}`;\n            menu.addItem({ command });\n        });\n        menu.addItem({ type: 'separator' });\n        menu.addItem({ command: 'gridwidth:cancel' });\n        /** About to Close Event: When the aboutToClose event of the menu is emitted\n         * (which happens just before the menu is actually closed),\n         * the this.menuOpen property is set to false to indicate the menu is not open.\n         * Simultaneously, this.preventOpen is set to true to prevent the menu from immediately reopening due to subsequent events.\n         * A setTimeout call is used to reset this.preventOpen to false in the next event loop cycle. */\n        menu.aboutToClose.connect(() => {\n            this.menuOpen = false;\n            this.preventOpen = true;\n            // console.log('menu about to close event');\n            setTimeout(() => {\n                this.preventOpen = false;\n                // console.log('menu successfully closed and can be opened again.');\n            }, 0);\n            // console.log('menu is waiting to be closed... prevent it to open...');\n        });\n        // create a toolbar button to envok the menu\n        const button = new ToolbarButton({\n            // the icon is similar to the previous split-cell extension button icon\n            iconClass: 'fa fa-arrows-h',\n            /** Button Click Event: When the toolbar button is clicked, the click event handler checks the state of this.menuOpen.\n             * The this.menuOpen is then set to true, indicating the menu is now open.\n             * If it's true, the menu is currently open and should be closed.\n             * If this.menuOpen is false and this.preventOpen is also false, the menu is not open and should be opened.\n             * The rect object represents the button's position, and menu.open positions the menu at the bottom-left of the button.*/\n            onClick: () => {\n                // console.log('button clicked');\n                if (this.menuOpen) {\n                    // Actually not envoked most of the time, no need to manually close the menu here,\n                    // because the menu will be closed automatically when this onClick event emits.\n                    menu.close();\n                    // console.log('menu closed');\n                }\n                else if (!this.preventOpen) {\n                    const rect = button.node.getBoundingClientRect();\n                    menu.open(rect.left, rect.bottom);\n                    this.menuOpen = true;\n                    // console.log('menu opened');\n                }\n            },\n            tooltip: 'Toogle Cell Width'\n        });\n        return button;\n    }\n}\nexport default plugin;\n"],"names":[],"sourceRoot":""}