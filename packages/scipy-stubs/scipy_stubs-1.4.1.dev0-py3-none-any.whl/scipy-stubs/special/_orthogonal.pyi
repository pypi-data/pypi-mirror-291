from collections.abc import Callable
from typing import Any, Literal, TypeAlias, overload

import numpy as np
import numpy.typing as npt

from scipy._typing import ArrayLike0D

_AnyInt: TypeAlias = int | np.integer[Any]
_AnyFloat: TypeAlias = float | np.floating[Any]
_PointsWeights: TypeAlias = tuple[npt.NDArray[np.float64], npt.NDArray[np.float64]]
_PointsWeightsMu: TypeAlias = tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], np.float64]

__all__ = [
    "chebyc",
    "chebys",
    "chebyt",
    "chebyu",
    "gegenbauer",
    "genlaguerre",
    "hermite",
    "hermitenorm",
    "jacobi",
    "laguerre",
    "legendre",
    "roots_chebyc",
    "roots_chebys",
    "roots_chebyt",
    "roots_chebyu",
    "roots_gegenbauer",
    "roots_genlaguerre",
    "roots_hermite",
    "roots_hermitenorm",
    "roots_jacobi",
    "roots_laguerre",
    "roots_legendre",
    "roots_sh_chebyt",
    "roots_sh_chebyu",
    "roots_sh_jacobi",
    "roots_sh_legendre",
    "sh_chebyt",
    "sh_chebyu",
    "sh_jacobi",
    "sh_legendre",
]

@overload
def roots_jacobi(n: _AnyInt, alpha: _AnyFloat, beta: _AnyFloat) -> _PointsWeights: ...
@overload
def roots_jacobi(n: _AnyInt, alpha: _AnyFloat, beta: _AnyFloat, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_jacobi(n: _AnyInt, alpha: _AnyFloat, beta: _AnyFloat, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_sh_jacobi(n: _AnyInt, p1: _AnyFloat, q1: _AnyFloat) -> _PointsWeights: ...
@overload
def roots_sh_jacobi(n: _AnyInt, p1: _AnyFloat, q1: _AnyFloat, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_sh_jacobi(n: _AnyInt, p1: _AnyFloat, q1: _AnyFloat, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_genlaguerre(n: _AnyInt, alpha: _AnyFloat) -> _PointsWeights: ...
@overload
def roots_genlaguerre(n: _AnyInt, alpha: _AnyFloat, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_genlaguerre(n: _AnyInt, alpha: _AnyFloat, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_laguerre(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_laguerre(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_laguerre(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_hermite(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_hermite(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_hermite(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_hermitenorm(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_hermitenorm(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_hermitenorm(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_gegenbauer(n: _AnyInt, alpha: _AnyFloat) -> _PointsWeights: ...
@overload
def roots_gegenbauer(n: _AnyInt, alpha: _AnyFloat, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_gegenbauer(n: _AnyInt, alpha: _AnyFloat, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_chebyt(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_chebyt(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_chebyt(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_chebyu(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_chebyu(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_chebyu(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_chebyc(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_chebyc(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_chebyc(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_chebys(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_chebys(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_chebys(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_sh_chebyt(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_sh_chebyt(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_sh_chebyt(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_sh_chebyu(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_sh_chebyu(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_sh_chebyu(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_legendre(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_legendre(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_legendre(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...
@overload
def roots_sh_legendre(n: _AnyInt) -> _PointsWeights: ...
@overload
def roots_sh_legendre(n: _AnyInt, mu: Literal[False]) -> _PointsWeights: ...
@overload
def roots_sh_legendre(n: _AnyInt, mu: Literal[True]) -> _PointsWeightsMu: ...

class orthopoly1d(np.poly1d):
    def __init__(
        self,
        roots: npt.ArrayLike,
        weights: npt.ArrayLike | None,
        hn: float = ...,
        kn: float = ...,
        wfunc: Callable[[float], float] | None = ...,
        limits: tuple[float, float] | None = ...,
        monic: bool = ...,
        eval_func: np.ufunc = ...,
    ) -> None: ...
    @property
    def limits(self) -> tuple[float, float]: ...
    def weight_func(self, x: float) -> float: ...
    @overload
    def __call__(self, x: ArrayLike0D) -> Any: ...
    @overload
    def __call__(self, x: np.poly1d) -> np.poly1d: ...
    @overload
    def __call__(self, x: npt.ArrayLike) -> npt.NDArray[np.float64] | npt.NDArray[np.complex128] | npt.NDArray[np.object_]: ...

def legendre(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def chebyt(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def chebyu(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def chebyc(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def chebys(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def jacobi(n: _AnyInt, alpha: _AnyFloat, beta: _AnyFloat, monic: bool = ...) -> orthopoly1d: ...
def laguerre(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def genlaguerre(n: _AnyInt, alpha: _AnyFloat, monic: bool = ...) -> orthopoly1d: ...
def hermite(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def hermitenorm(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def gegenbauer(n: _AnyInt, alpha: _AnyFloat, monic: bool = ...) -> orthopoly1d: ...
def sh_legendre(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def sh_chebyt(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def sh_chebyu(n: _AnyInt, monic: bool = ...) -> orthopoly1d: ...
def sh_jacobi(n: _AnyInt, p: _AnyFloat, q: _AnyFloat, monic: bool = ...) -> orthopoly1d: ...

# These functions are not public, but still need stubs because they
# get checked in the tests.
def _roots_hermite_asy(n: _AnyInt) -> _PointsWeights: ...
