#!/usr/bin/env python3
import BioSimSpace as BSS
import BioSimSpace.Sandpit.Exscientia as BSE
import os
import numpy as np
import argparse
import pandas as pd
import glob
import shutil

parser = argparse.ArgumentParser \
    ( formatter_class=argparse.RawDescriptionHelpFormatter,
      description="""
Generate the parameter files for absolute free energy simulation, including absolute solvation free energy(ASFE) and absolute binding free energy(ABFE). Use Gromacs in Default. It searches restraints for ABFE by using long trajectories which generated by the previous step(06_RestraintSearch) in com phase by AFE_parameter.py. BSS supports boresch and multiple distance restraints(https://pubs.acs.org/doi/full/10.1021/acs.jctc.3c00139), but here only use boresch. Here we don't modify the ligand region selected for restraints searching. 
""" )



parser.add_argument \
    ("-t","--types",
     help="The type of free energy simulations: absolute solvation free energy (ASFE) or absolute binding free energy (ABFE).",
#     nargs='+',
     choices=['ASFE','ABFE'],
     type=str,
     required=True )


     
parser.add_argument \
    ("-f","--filepath",
     help="Please provide the folder path for pre-equilirbium system. The default is Prep, which is created by AFE_parameter.py. The path organization is like this, i.e. Prep/{sys_name}/lig/05_npt_relax for ligand and ,Prep/{sys_name}/com/06_RestraintSearch for complex, where this python script is trying to locate.",
     type=str,
     required=True,
     default="Prep" )


parser.add_argument \
    ("-s","--sys",
     help=("The system names {sys_name}, which is used for searching folder in {filepath} you provided. In default, this script search all systems in the {filepath} you provided. But in the case that you only want to set up one or several specific system. Here also provide this flag option. You specify the systems such as -s ejm31 ejm55, then this script will just only set up free energy for these two systems."),
     type=str,
     #action='append',
     nargs='*',
     required=False )


parser.add_argument \
    ("-ts","--timestep",
     help="Each of the lambda window will run with minization, NVT, NPT and Production, except that no NPT in vacuum phase. The time step here is just for production, and the unit is nanosecond. Default is 5.0 ns.",
     type=float,
     required=False,
     default=5.0,

    )



parser.add_argument \
    ("-tl","--trials",
     help="The number of trials for repeating the simulation for each of them. Default is 1.",
     type=int,
     required=False,
     default=1,

    )


parser.add_argument \
    ("-nlam","--nlambdas",
     help="The number of lambda for each steps. Complex phase(protein+ligand) includes restraint, coul, and vdw steps. Solvation phase(ligand) includes coul and vdw steps. Vacuum phase includes coul and vdw steps. You can specify the number of lambda windows for each steps based on the order mentioned above. i.e. 6 9 21 9 11 9 11 means {'restraint': 6 , 'coul': 9, 'vdw': 21} for complex phase, {'coul': 9, 'vdw': 11} for solvation phase, and {'coul': 9, 'vdw': 11} for vacuum phase. That is the default setting. If you want to specify, please provide all information even though you just want to run ASFE which does not need complex phase. The order is important here.",
     type=int,
     nargs='+',
     default=[6, 9, 21, 9, 11, 9, 11],
     required=False )


parser.add_argument \
    ("-o","--output",
     help="The output directory. Default is FreeEnergy",
     type=str,
     default="FreeEnergy",
     required=False )



args = parser.parse_args()
print("type = ", args.types)
print("filepath = ", args.filepath)
print("sysnames = ", args.sys)
print(f"time step = {args.timestep} ns")
print("trials = ", args.trials)
print("output = ", args.output)
print("nlambdas=", args.nlambdas)


def readRestraint(fname):
    fh=open(fname,"r")

    data={}
    for line in fh:
        cols=line.strip().split()
        #print(cols)
        if "r1" in line:
            #print(cols)
            data['r1']=int(cols[-1])
        if 'r2' in line:
            data['r2']=int(cols[-1])
        if 'r3' in line:
            data['r3']=int(cols[-1])
        if "l1" in line:
            #print(cols)
            data['l1']=int(cols[-1])
        if 'l2' in line:
            data['l2']=int(cols[-1])
        if 'l3' in line:
            data['l3']=int(cols[-1])    

        if 'r0' in line:
            data['r0']=[float(cols[1]), cols[2]]

        if 'thetaA0' in line:
            data['thetaA0']=[float(cols[1]), cols[2]]
        
        if 'thetaB0' in line:
            data['thetaB0']=[float(cols[1]), cols[2]]
        if 'phiA0' in line:
            data['phiA0']=[float(cols[1]), cols[2]]
        if 'phiB0' in line:
            data['phiB0']=[float(cols[1]), cols[2]]
        if 'phiC0' in line:
            data['phiC0']=[float(cols[1]), cols[2]]
        
        if 'kr' in line:
            data['kr']=[float(cols[1]), cols[2]]

        if 'kthetaA' in line:
            data['kthetaA']=[float(cols[1]), cols[2]]
        
        if 'kthetaB' in line:
            data['kthetaB']=[float(cols[1]), cols[2]]
        if 'kphiA' in line:
            data['kphiA']=[float(cols[1]), cols[2]]
        if 'kphiB' in line:
            data['kphiB']=[float(cols[1]), cols[2]]
        if 'kphiC' in line:
            data['kphiC']=[float(cols[1]), cols[2]]
    fh.close()
    return data
        
    



def CreateLamsDict(array):
    com_data={'bonded':[],'coul':[],'vdw':[]}
    sol_data={'coul':[],'vdw':[]}
    vac_data={'coul':[],'vdw':[]}
    if len(array) < 7:
        raise Exception(f"{array} contains less than 7 elements.")
    else:
        com_tlams=array[0]+array[1]+array[2] - 2 
        sol_tlams=array[3]+array[4] -1
        vac_tlams=array[5]+array[6] -1 

    
   
        com_bonded_lams=[i/(array[0]-1.) for i in range(array[0])]
        com_coul_lams=[i/(array[1]-1.) for i in range(array[1])]
        com_vdw_lams=[i/(array[2]-1.) for i in range(array[2])]

        sol_coul_lams=[i/(array[3]-1.) for i in range(array[3])]
        sol_vdw_lams=[i/(array[4]-1.) for i in range(array[4])]

        vac_coul_lams=[i/(array[5]-1.) for i in range(array[5])]
        vac_vdw_lams=[i/(array[6]-1.) for i in range(array[6])]
    


        
        #print(com_bonded_lams)
        #print(com_coul_lams)
        #print(com_vdw_lams)

        ## Gromacs can control different terms scaled by lambda independently. Here we scale bonded term, and then coul and last for vdw in the complex phase. 
        
        for i in range(com_tlams):
            if i < len(com_bonded_lams):
                com_data['bonded'].append(com_bonded_lams[i])
                com_data['coul'].append(0.0)
                com_data['vdw'].append(0.0)
        
            
                
                
            elif i < len(com_bonded_lams)+len(com_coul_lams)-1:
                k=i-(len(com_bonded_lams)-1)
                com_data['bonded'].append(1.0)
                com_data['coul'].append(com_coul_lams[k])
                com_data['vdw'].append(0.0)

            else:
                j = i - (len(com_bonded_lams)+len(com_coul_lams) -2 )
                com_data['bonded'].append(1.0)
                com_data['coul'].append(1.0)
                com_data['vdw'].append(com_vdw_lams[j])

        #print(com_data)
        #print(len(com_data['bonded']),len(com_data['coul']),len(com_data['vdw']))
        #print(sol_coul_lams)
        #print(sol_vdw_lams)
        #print(sol_tlams)
        for i in range(sol_tlams):
            if i < len(sol_coul_lams):
                sol_data['coul'].append(sol_coul_lams[i])
                sol_data['vdw'].append(0.0)
            else:
                k=i-(len(sol_coul_lams)-1)
                sol_data['coul'].append(1.0)
                sol_data['vdw'].append(sol_vdw_lams[k])
        #print(sol_data)
        #print(len(sol_data['coul']),len(sol_data['vdw']))


        #print(vac_coul_lams)
        #print(vac_vdw_lams)
        #print(vac_tlams)
    
        for i in range(vac_tlams):
            if i < len(vac_coul_lams):
                vac_data['coul'].append(vac_coul_lams[i])
                vac_data['vdw'].append(0.0)
            else:
                k=i-(len(vac_coul_lams)-1)
                vac_data['coul'].append(1.0)
                vac_data['vdw'].append(vac_vdw_lams[k])
        #print(vac_data)
        #print(len(vac_data['coul']),len(vac_data['vdw']))

        return com_data, sol_data, vac_data




com_data,sol_data,vac_data = CreateLamsDict(args.nlambdas)


com_initial_lam=pd.Series(data={'bonded': 0.0, 'coul': 0.0, 'vdw': 0.0})
sol_initial_lam=pd.Series(data={'coul': 0.0, 'vdw': 0.0})
vac_initial_lam=pd.Series(data={'coul': 0.0, 'vdw': 0.0})
com_gromacs_lams=pd.DataFrame(com_data)
sol_gromacs_lams=pd.DataFrame(sol_data)
vac_gromacs_lams=pd.DataFrame(vac_data)


## Let user to specify the systems, or else we search them by ourself. 
if args.sys == None:
    paths=sorted(glob.glob(f"{args.filepath}/*"))
else:
    paths=[]
    for i in args.sys:
        paths.append(f"{args.filepath}/{i}")
#print(paths)

if len(paths) == 0:
    raise Exception(f"{args.filepath} is empty! Please double check!")
else:
    for filepath in paths:
        sysname = filepath.split("/")[-1]
        sol_gro=f"{filepath}/lig/05_npt_relax/05_npt_relax_out.gro"
        sol_top=f"{filepath}/lig/05_npt_relax/05_npt_relax.top"
        if args.types == "ABFE":
            ## To be consistent with RFE, here we also use the same equilibrium structures. 
            
            com_gro=f"{filepath}/com/05_npt_relax/05_npt_relax_out.gro"
            com_top=f"{filepath}/com/05_npt_relax/05_npt_relax.top"
            
            if not os.path.exists(com_gro) or not os.path.exists(com_top):
                raise Exception(f"Either {com_gro} or {com_top} not exists!")
            else:
                print(f"Start searching the restraints in complex phase for {sysname}")    
                com_sys= BSE.IO.readMolecules([com_gro,com_top])
                ### just in case that the ligand does not rank in the first place
                n_residues = [mol.nResidues() for mol in com_sys]
                n_atoms = [mol.nAtoms() for mol in com_sys]

                lig_idx=None
                for k, (n_resi, n_at) in enumerate(zip(n_residues[:20], n_atoms[:20])):
                    if n_resi == 1 and n_at > 5:
                        lig_idx = k
                    else:
                        pass

                if isinstance(lig_idx,int):
                    print(f"The index of ligand is {lig_idx}")
                    decouple_lig = BSE.Align.decouple(com_sys[lig_idx])
                    com_sys.updateMolecule(lig_idx, decouple_lig)
                else:
                    raise Exception("Cannot find ligand index!")
                


                com_path=f"{args.output}/{sysname}/template/com"
                if not os.path.exists(com_path):
                    os.makedirs(com_path)

                if not os.path.exists(f"{com_path}/submit_slurm.sh"):
                    fh = open(f"{com_path}/submit_slurm.sh","w")
                    fh.write(
                        """#!/bin/bash
#SBATCH --job-name=COM%s
#SBATCH --time=48:00:00
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=10
#SBATCH --mem-per-cpu=1GB
#SBATCH --partition=bsc120c
#SBATCH --exclude=bsc120c-pg0-[1-3],bsc120c-pg0-[5-30]
#SBATCH --no-requeue
source /anfhome/.profile
module load gromacs
export GMX="gmx_mpi"
export LAUNCH="mpirun -np 10"

NLAM=%i
"""%(sysname, len(com_gromacs_lams['vdw'])))
                    fh.write(
                        """
LAMS=($( for i in $(seq 0 1 $((${NLAM}-1))); do printf " %d" ${i}; done))

steps=(min nvt npt pro)
for i in $(seq 0 $((${#steps[@]}-1)));do
    for ilam in ${LAMS[@]};do
        lam=$(printf "lambda_%s" ${ilam})
        if [ ! -e "${steps[$i]}/${lam}/gromacs.log" ];then
            echo "${steps[$i]}/${lam}/gromacs.log not exist and start running..."
            if [ $i == 0 ];then
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$i]}/${lam}/gromacs.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            elif [ $i == 1 ];then
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            else
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -t ${steps[$(($i-1))]}/${lam}/gromacs.cpt -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            fi
        else
            value=$(tail -n 2 ${steps[$i]}/${lam}/gromacs.log | head -n 1 |  awk '{print $1}')
            if [[ ${value} != "Finished" ]];then
                echo "${steps[$i]}/${lam}/gromacs.log not finished and start running..."
                if [ $i == 0 ];then
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$i]}/${lam}/gromacs.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                elif [ $i == 1 ];then
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                else
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -t ${steps[$(($i-1))]}/${lam}/gromacs.cpt -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                fi
            else
                echo "${steps[$i]}/${lam} finished"
            fi

        fi
    done


done
"""
                    )
                    fh.close()
                    
                    
                if not os.path.exists(f"{com_path}/restraint.dat"):
                    com_prm=f"{filepath}/com/system.prm7"
                    com_xtc=f"{filepath}/com/06_RestraintSearch/06_RestraintSearch.xtc"
                    if not os.path.exists(com_prm) or not os.path.exists(com_xtc):
                        # Only amber topology works for restraints searching, I have reported to BioSimSpace, still waiting for reply...
                        raise Exception(f"Either {com_prm} or {com_xtc} not exists! They are used for restraints searching.")
                    else:
                        traj=BSE.Trajectory.Trajectory(trajectory=com_xtc, topology=com_prm)

                        restraint = BSE.FreeEnergy.RestraintSearch.analyse( work_dir=f"{filepath}/com/06_RestraintSearch/",
                                                                            system=com_sys,
                                                                            traj = traj,
                                                                            temperature = 300 * BSE.Units.Temperature.kelvin,
                                                                            method="BSS",
                                                                            restraint_type = "Boresch")



                    

                        rest_dict=restraint._restraint_dict
                    
                        ## Write down restraints information and dG_release result, so that we don't need to recalculate.
                        fh=open(f"{com_path}/restraint.dat","w")
                        fh.write(
                            f"""GROMACS FORMAT
{restraint.toString(engine="Gromacs")}
"""
                        )
                        # Atom index starting from 0, different from Gromacs; the unit is also different from Gromacs which uses kJ/mol
                        fh.write(
                            f"""RESTRAINT BSS INFO 
anchor_points
r1: {com_sys.getIndex(rest_dict['anchor_points']['r1'])}
r2: {com_sys.getIndex(rest_dict['anchor_points']['r2'])}
r3: {com_sys.getIndex(rest_dict['anchor_points']['r3'])}
l1: {com_sys.getIndex(rest_dict['anchor_points']['l1'])}
l2: {com_sys.getIndex(rest_dict['anchor_points']['l2'])}
l3: {com_sys.getIndex(rest_dict['anchor_points']['l3'])}

equilibrium_values
r0: {rest_dict['equilibrium_values']['r0']}
thetaA0: {rest_dict['equilibrium_values']['thetaA0']}
thetaB0: {rest_dict['equilibrium_values']['thetaB0']}
phiA0: {rest_dict['equilibrium_values']['phiA0']}
phiB0: {rest_dict['equilibrium_values']['phiB0']}
phiC0: {rest_dict['equilibrium_values']['phiC0']}

force_constants
kr: {rest_dict['force_constants']['kr']}
kthetaA: {rest_dict['force_constants']['kthetaA']}
kthetaB: {rest_dict['force_constants']['kthetaB']}
kphiA: {rest_dict['force_constants']['kphiA']}
kphiB: {rest_dict['force_constants']['kphiB']}
kphiC: {rest_dict['force_constants']['kphiC']}
"""
                        )
                        fh.write(
                            f"""FREE ENERGY RELEASE VALUE 
{restraint.getCorrection()}
"""
                        )
                        fh.close()
                else:
                    ## reading restraint.dat file to get restraints.
                    param=readRestraint(f"{com_path}/restraint.dat")

                    from BioSimSpace.Sandpit.Exscientia.Units.Length import angstrom
                    from BioSimSpace.Sandpit.Exscientia.Units.Angle import radian, degree
                    from BioSimSpace.Sandpit.Exscientia.Units.Energy import kcal_per_mol

                    # Assign three atoms from the protein
                    r1 = com_sys.getAtom(param['r1'])
                    r2 = com_sys.getAtom(param['r2'])
                    r3 = com_sys.getAtom(param['r3'])

                    # Assign three atoms from the ligand
                    l1 = com_sys.getAtom(param['l1'])
                    l2 = com_sys.getAtom(param['l2'])
                    l3 = com_sys.getAtom(param['l3'])

                    if param['r0'][1] == "A":
                        r0 = param['r0'][0] * angstrom
                    else:
                        raise Exception(f"Please double check r0 unit in {com_path}/restraint.dat. Please make sure it uses 'A'.")

                    if param['thetaA0'][1] == "radians":
                        thetaA0 =param['thetaA0'][0] * radian
                    else:
                        raise Exception(f"Please double check thetaA0 unit in {com_path}/restraint.dat. Please make sure it uses 'radians'.")

                    if param['thetaB0'][1] == "radians":
                        thetaB0 =param['thetaB0'][0] * radian
                    else:
                        raise Exception(f"Please double check thetaB0 unit in {com_path}/restraint.dat. Please make sure it uses 'radians'.")
                    
                    if param['phiA0'][1] == "radians":
                        phiA0 =param['phiA0'][0] * radian
                    else:
                        raise Exception(f"Please double check phiA0 unit in {com_path}/restraint.dat. Please make sure it uses 'radians'.")

                    if param['phiB0'][1] == "radians":
                        phiB0 =param['phiB0'][0] * radian
                    else:
                        raise Exception(f"Please double check phiB0 unit in {com_path}/restraint.dat. Please make sure it uses 'radians'.")

                    if param['phiC0'][1] == "radians":
                        phiC0 =param['phiC0'][0] * radian
                    else:
                        raise Exception(f"Please double check phiC0 unit in {com_path}/restraint.dat. Please make sure it uses 'radians'.")
                    

                    if param['kr'][1] == "kcal":
                        kr = param['kr'][0] * kcal_per_mol / angstrom**2
                    else:
                        raise Exception(f"Please double check kr unit in {com_path}/restraint.dat. Please make sure it uses 'kcal mol-1 A-2'.")

                    if param['kthetaA'][1] == "kcal":
                        kthetaA =param['kthetaA'][0] * kcal_per_mol / (radian * radian)
                    else:
                        raise Exception(f"Please double check kthetaA unit in {com_path}/restraint.dat. Please make sure it uses 'kcal mol-1 °-2'.")

                    if param['kthetaB'][1] == "kcal":
                        kthetaB =param['kthetaB'][0] * kcal_per_mol / (radian * radian)
                    else:
                        raise Exception(f"Please double check kthetaB unit in {com_path}/restraint.dat. Please make sure it uses 'kcal mol-1 °-2'.")
                    

                    if param['kphiA'][1] == "kcal":
                        kphiA =param['kphiA'][0] * kcal_per_mol / (radian * radian)
                    else:
                        raise Exception(f"Please double check kphiA unit in {com_path}/restraint.dat. Please make sure it uses 'kcal mol-1 °-2'.")

                    if param['kphiB'][1] == "kcal":
                        kphiB =param['kphiB'][0] * kcal_per_mol / (radian * radian)
                    else:
                        raise Exception(f"Please double check kphiB unit in {com_path}/restraint.dat. Please make sure it uses 'kcal mol-1 °-2'.")

                    if param['kphiC'][1] == "kcal":
                        kphiC =param['kphiC'][0] * kcal_per_mol / (radian * radian)
                    else:
                        raise Exception(f"Please double check kphiC unit in {com_path}/restraint.dat. Please make sure it uses 'kcal mol-1 °-2'.")
                    

                    restraint_dict = {
                        "anchor_points": {"r1": r1, "r2": r2, "r3": r3, "l1": l1, "l2": l2, "l3": l3},
                        "equilibrium_values": {
                            "r0": r0,
                            "thetaA0": thetaA0,
                            "thetaB0": thetaB0,
                            "phiA0": phiA0,
                            "phiB0": phiB0,
                            "phiC0": phiC0,
                        },
                        "force_constants": {
                            "kr": kr,
                            "kthetaA": kthetaA,
                            "kthetaB": kthetaB,
                            "kphiA": kphiA,
                            "kphiB": kphiB,
                            "kphiC": kphiC,
                        },
                    }

                    #print(restraint_dict)
                    #exit(0)
                    restraint = BSE.FreeEnergy.Restraint(com_sys, restraint_dict, 300*BSE.Units.Temperature.kelvin)

                                    
                ## Different from RFE simulation, here we use stepwise, scaling coul and vdw step by step.
                print(f"Setting up free energy protocol in complex phase for {sysname}")
                com_min_protocol=BSE.Protocol.FreeEnergyMinimisation(lam=com_initial_lam,
                                                                     lam_vals=com_gromacs_lams,
                                                                     perturbation_type="full")
                    
                com_nvt_protocol=BSE.Protocol.FreeEnergyEquilibration(lam=com_initial_lam,
                                                                    lam_vals=com_gromacs_lams,
                                                                      perturbation_type="full",
                                                                      pressure=None)
                    
                com_npt_protocol=BSE.Protocol.FreeEnergyEquilibration(lam=com_initial_lam,
                                                                      lam_vals=com_gromacs_lams,
                                                                      perturbation_type="full",
                                                                      pressure=1 * BSE.Units.Pressure.atm)
                    
                com_pro_protocol=BSE.Protocol.FreeEnergy(runtime=args.timestep*BSE.Units.Time.nanosecond, 
                                                         lam=com_initial_lam,
                                                         lam_vals=com_gromacs_lams, 
                                                         perturbation_type="full")



                if not os.path.exists(f"{com_path}/min"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(com_sys,
                                                        com_min_protocol,
                                                        engine='gromacs', restraint=restraint,
                                                        work_dir=f'{com_path}/min')
                        
                if not os.path.exists(f"{com_path}/nvt"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(com_sys,
                                                        com_nvt_protocol,
                                                        engine='gromacs', restraint=restraint,
                                                        work_dir=f'{com_path}/nvt')

                if not os.path.exists(f"{com_path}/npt"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(com_sys,
                                                        com_npt_protocol,
                                                        engine='gromacs', restraint=restraint,
                                                        work_dir=f'{com_path}/npt')

                if not os.path.exists(f"{com_path}/pro"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(com_sys,
                                                        com_pro_protocol,
                                                        engine='gromacs', restraint=restraint,
                                                        work_dir=f'{com_path}/pro')
                        

            if not os.path.exists(sol_gro) or not os.path.exists(sol_top):
                raise Exception(f"Either {sol_gro} or {sol_top} not exists!")
            else:
                print(f"Setting up free energy protocol in solvation phase for {sysname}")    
                sol_sys= BSE.IO.readMolecules([sol_gro,sol_top])
                sol_path=f"{args.output}/{sysname}/template/sol"
                if not os.path.exists(sol_path):
                    os.makedirs(sol_path)
                if not os.path.exists(f"{sol_path}/submit_slurm.sh"):
                    fh = open(f"{sol_path}/submit_slurm.sh","w")
                    fh.write(
                        """#!/bin/bash
#SBATCH --job-name=SOL%s
#SBATCH --time=48:00:00
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=10
#SBATCH --mem-per-cpu=1GB
#SBATCH --partition=bsc120c
#SBATCH --exclude=bsc120c-pg0-[1-3],bsc120c-pg0-[5-30]
#SBATCH --no-requeue
source /anfhome/.profile
module load gromacs
export GMX="gmx_mpi"
export LAUNCH="mpirun -np 10"

NLAM=%i
"""%(sysname, len(sol_gromacs_lams['vdw'])))
                    fh.write(
                        """
LAMS=($( for i in $(seq 0 1 $((${NLAM}-1))); do printf " %d" ${i}; done))

steps=(min nvt npt pro)
for i in $(seq 0 $((${#steps[@]}-1)));do
    for ilam in ${LAMS[@]};do
        lam=$(printf "lambda_%s" ${ilam})
        if [ ! -e "${steps[$i]}/${lam}/gromacs.log" ];then
            echo "${steps[$i]}/${lam}/gromacs.log not exist and start running..."
            if [ $i == 0 ];then
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$i]}/${lam}/gromacs.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            elif [ $i == 1 ];then
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            else
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -t ${steps[$(($i-1))]}/${lam}/gromacs.cpt -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            fi
        else
            value=$(tail -n 2 ${steps[$i]}/${lam}/gromacs.log | head -n 1 |  awk '{print $1}')
            if [[ ${value} != "Finished" ]];then
                echo "${steps[$i]}/${lam}/gromacs.log not finished and start running..."
                if [ $i == 0 ];then
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$i]}/${lam}/gromacs.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                elif [ $i == 1 ];then
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                else
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -t ${steps[$(($i-1))]}/${lam}/gromacs.cpt -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                fi
            else
                echo "${steps[$i]}/${lam} finished"
            fi

        fi
    done


done
"""
                    )
                    fh.close()
                    
                    
                ## Assuming the ligand ranked the 1st in the solvation topology file
                lig = BSE.Align.decouple(sol_sys[0])
                sol_sys.updateMolecule(0, lig)
                

                sol_min_protocol=BSE.Protocol.FreeEnergyMinimisation(lam=sol_initial_lam,
                                                                     lam_vals=sol_gromacs_lams,
                                                                     perturbation_type="full")
                    
                sol_nvt_protocol=BSE.Protocol.FreeEnergyEquilibration(lam=sol_initial_lam,
                                                                      lam_vals=sol_gromacs_lams,
                                                                      perturbation_type="full",
                                                                      pressure=None)
                
                sol_npt_protocol=BSE.Protocol.FreeEnergyEquilibration(lam=sol_initial_lam,
                                                                      lam_vals=sol_gromacs_lams,
                                                                      perturbation_type="full",
                                                                      pressure=1 * BSE.Units.Pressure.atm)
                    
                sol_pro_protocol=BSE.Protocol.FreeEnergy(runtime=args.timestep*BSE.Units.Time.nanosecond, 
                                                         lam=sol_initial_lam,
                                                         lam_vals=sol_gromacs_lams, 
                                                         perturbation_type="full")


                
                if not os.path.exists(f"{sol_path}/min"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(sol_sys,
                                                        sol_min_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{sol_path}/min')
                        
                if not os.path.exists(f"{sol_path}/nvt"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(sol_sys,
                                                        sol_nvt_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{sol_path}/nvt')

                if not os.path.exists(f"{sol_path}/npt"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(sol_sys,
                                                        sol_npt_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{sol_path}/npt')

                if not os.path.exists(f"{sol_path}/pro"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(sol_sys,
                                                        sol_pro_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{sol_path}/pro')
                    
                
                    


                    
                    
        elif args.types == "ASFE":
            
            if not os.path.exists(sol_gro) or not os.path.exists(sol_top):
                raise Exception(f"Either {sol_gro} or {sol_top} not exists!")
            else:
                print(f"Setting up free energy protocol in solvation phase for {sysname}")    
                sol_sys= BSE.IO.readMolecules([sol_gro,sol_top])
                sol_path=f"{args.output}/{sysname}/template/sol"
                if not os.path.exists(sol_path):
                    os.makedirs(sol_path)
                if not os.path.exists(f"{sol_path}/submit_slurm.sh"):
                    fh = open(f"{sol_path}/submit_slurm.sh","w")
                    fh.write(
                        """#!/bin/bash
#SBATCH --job-name=SOL%s
#SBATCH --time=48:00:00
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=10
#SBATCH --mem-per-cpu=1GB
#SBATCH --partition=bsc120c
#SBATCH --exclude=bsc120c-pg0-[1-3],bsc120c-pg0-[5-30]
#SBATCH --no-requeue
source /anfhome/.profile
module load gromacs
export GMX="gmx_mpi"
export LAUNCH="mpirun -np 10"

NLAM=%i
"""%(sysname, len(sol_gromacs_lams['vdw'])))
                    fh.write(
                        """
LAMS=($( for i in $(seq 0 1 $((${NLAM}-1))); do printf " %d" ${i}; done))

steps=(min nvt npt pro)
for i in $(seq 0 $((${#steps[@]}-1)));do
    for ilam in ${LAMS[@]};do
        lam=$(printf "lambda_%s" ${ilam})
        if [ ! -e "${steps[$i]}/${lam}/gromacs.log" ];then
            echo "${steps[$i]}/${lam}/gromacs.log not exist and start running..."
            if [ $i == 0 ];then
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$i]}/${lam}/gromacs.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            elif [ $i == 1 ];then
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            else
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -t ${steps[$(($i-1))]}/${lam}/gromacs.cpt -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            fi
        else
            value=$(tail -n 2 ${steps[$i]}/${lam}/gromacs.log | head -n 1 |  awk '{print $1}')
            if [[ ${value} != "Finished" ]];then
                echo "${steps[$i]}/${lam}/gromacs.log not finished and start running..."
                if [ $i == 0 ];then
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$i]}/${lam}/gromacs.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                elif [ $i == 1 ];then
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                else
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -t ${steps[$(($i-1))]}/${lam}/gromacs.cpt -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 1 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                fi
            else
                echo "${steps[$i]}/${lam} finished"
            fi

        fi
    done


done
"""
                    )
                    fh.close()
                    
                    
                
                ## Assuming the ligand ranked the 1st in the solvation topology file
                lig = BSE.Align.decouple(sol_sys[0])
                sol_sys.updateMolecule(0, lig)
                

                sol_min_protocol=BSE.Protocol.FreeEnergyMinimisation(lam=sol_initial_lam,
                                                                     lam_vals=sol_gromacs_lams,
                                                                     perturbation_type="full")
                    
                sol_nvt_protocol=BSE.Protocol.FreeEnergyEquilibration(lam=sol_initial_lam,
                                                                      lam_vals=sol_gromacs_lams,
                                                                      perturbation_type="full",
                                                                      pressure=None)
                
                sol_npt_protocol=BSE.Protocol.FreeEnergyEquilibration(lam=sol_initial_lam,
                                                                      lam_vals=sol_gromacs_lams,
                                                                      perturbation_type="full",
                                                                      pressure=1 * BSE.Units.Pressure.atm)


                ## Because vacuum cannot run NPT, to be consistent, solvation phase also uses NVT. 
                sol_pro_protocol=BSE.Protocol.FreeEnergy(runtime=args.timestep*BSE.Units.Time.nanosecond, 
                                                         lam=sol_initial_lam,
                                                         lam_vals=sol_gromacs_lams, 
                                                         perturbation_type="full",
                                                         pressure=None)


                
                if not os.path.exists(f"{sol_path}/min"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(sol_sys,
                                                        sol_min_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{sol_path}/min')
                        
                if not os.path.exists(f"{sol_path}/nvt"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(sol_sys,
                                                        sol_nvt_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{sol_path}/nvt')

                if not os.path.exists(f"{sol_path}/npt"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(sol_sys,
                                                        sol_npt_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{sol_path}/npt')

                if not os.path.exists(f"{sol_path}/pro"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(sol_sys,
                                                        sol_pro_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{sol_path}/pro')
                    


                print(f"Setting up free energy protocol in vacuum phase for {sysname}")
                ### assuming that the ligand ranked in the first place in solvation system.
                mol=sol_sys.getMolecule(0)
                vac_sys=mol.toSystem()
                
                vac_path=f"{args.output}/{sysname}/template/vac"
                if not os.path.exists(vac_path):
                    os.makedirs(vac_path)

                if not os.path.exists(f"{vac_path}/submit_slurm.sh"):
                    fh = open(f"{vac_path}/submit_slurm.sh","w")
                    fh.write(
                        """#!/bin/bash
#SBATCH --job-name=VAC%s
#SBATCH --time=48:00:00
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=10
#SBATCH --mem-per-cpu=1GB
#SBATCH --partition=bsc120c
#SBATCH --exclude=bsc120c-pg0-[1-3],bsc120c-pg0-[5-30]
#SBATCH --no-requeue
source /anfhome/.profile
module load gromacs
export GMX="gmx_mpi"
export LAUNCH="mpirun -np 1"

NLAM=%i
"""%(sysname, len(vac_gromacs_lams['vdw'])))
                    fh.write(
                        """
LAMS=($( for i in $(seq 0 1 $((${NLAM}-1))); do printf " %d" ${i}; done))

steps=(min nvt pro)
for i in $(seq 0 $((${#steps[@]}-1)));do
    for ilam in ${LAMS[@]};do
        lam=$(printf "lambda_%s" ${ilam})
        if [ ! -e "${steps[$i]}/${lam}/gromacs.log" ];then
            echo "${steps[$i]}/${lam}/gromacs.log not exist and start running..."
            if [ $i == 0 ];then
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$i]}/${lam}/gromacs.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 10 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            elif [ $i == 1 ];then
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 10 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            else
                echo "Running ${steps[$i]}/${lam}"
                ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -t ${steps[$(($i-1))]}/${lam}/gromacs.cpt -o ${steps[$i]}/${lam}/gromacs.tpr
                ${LAUNCH} ${GMX} mdrun -ntomp 10 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
            fi
        else
            value=$(tail -n 2 ${steps[$i]}/${lam}/gromacs.log | head -n 1 |  awk '{print $1}')
            if [[ ${value} != "Finished" ]];then
                echo "${steps[$i]}/${lam}/gromacs.log not finished and start running..."
                if [ $i == 0 ];then
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$i]}/${lam}/gromacs.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 10 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                elif [ $i == 1 ];then
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 10 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                else
                    echo "Running ${steps[$i]}/${lam}"
                    ${LAUNCH} ${GMX} grompp -f ${steps[$i]}/${lam}/gromacs.mdp -c ${steps[$(($i-1))]}/${lam}/gromacs_out.gro -p ${steps[$i]}/${lam}/gromacs.top  -t ${steps[$(($i-1))]}/${lam}/gromacs.cpt -o ${steps[$i]}/${lam}/gromacs.tpr
                    ${LAUNCH} ${GMX} mdrun -ntomp 10 -deffnm ${steps[$i]}/${lam}/gromacs -c ${steps[$i]}/${lam}/gromacs_out.gro
                fi
            else
                echo "${steps[$i]}/${lam} finished"
            fi

        fi
    done


done
"""
                    )
                    fh.close()
                    
                vac_min_protocol=BSE.Protocol.FreeEnergyMinimisation(lam=vac_initial_lam,
                                                                     lam_vals=vac_gromacs_lams,
                                                                     perturbation_type="full")
                    
                vac_nvt_protocol=BSE.Protocol.FreeEnergyEquilibration(lam=vac_initial_lam,
                                                                      lam_vals=vac_gromacs_lams,
                                                                      perturbation_type="full",
                                                                      pressure=None)
                


                ## Because vacuum cannot run NPT
                vac_pro_protocol=BSE.Protocol.FreeEnergy(runtime=args.timestep*BSE.Units.Time.nanosecond, 
                                                         lam=vac_initial_lam,
                                                         lam_vals=vac_gromacs_lams, 
                                                         perturbation_type="full",
                                                         pressure=None)


                
                if not os.path.exists(f"{vac_path}/min"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(vac_sys,
                                                        vac_min_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{vac_path}/min')
                        
                if not os.path.exists(f"{vac_path}/nvt"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(vac_sys,
                                                        vac_nvt_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{vac_path}/nvt')

                
                if not os.path.exists(f"{vac_path}/pro"):
                    BSE.FreeEnergy.AlchemicalFreeEnergy(vac_sys,
                                                        vac_pro_protocol,
                                                        engine='gromacs', restraint=None,
                                                        work_dir=f'{vac_path}/pro')
                    




        if os.path.exists(f"{args.output}/{sysname}/template/"):
            for itrial in range(args.trials):
                trial_name="t%02d"%(itrial+1)
                if not os.path.exists(f"{args.output}/{sysname}/{trial_name}/"):
                    shutil.copytree(f"{args.output}/{sysname}/template/", f"{args.output}/{sysname}/{trial_name}/")
                else:

                    if args.types == "ASFE":
                        if not os.path.exists(f"{args.output}/{sysname}/{trial_name}/vac"):
                            shutil.copytree(f"{args.output}/{sysname}/template/vac", f"{args.output}/{sysname}/{trial_name}/vac")

                    elif args.types == "ABFE":
                        if not os.path.exists(f"{args.output}/{sysname}/{trial_name}/com"):
                            shutil.copytree(f"{args.output}/{sysname}/template/com", f"{args.output}/{sysname}/{trial_name}/com")
