快速入门 | 结账支付 | 支付宝文档
==================

[![图片1：中国领先的第三方在线支付解决方案 - 支付宝](https://ac.alipay.com/storage/2024/3/26/d66c43c0-440d-4c97-9976-f2028a2c8c5e.svg)](/docs/)
[![图片2：中国领先的第三方在线支付解决方案 - 支付宝](https://ac.alipay.com/storage/2024/3/26/a48bd336-aea0-4f16-bf83-616eacbb4434.svg)](/docs/)

[登录](https://global.alipay.com/ilogin/account_login.htm?goto=https%3A%2F%2Fglobal.alipay.com%2Fdocs%2Fac%2Fcashierpay%2Fquickstart)
[返回首页](../../)

结账支付
[概述](/docs/ac/cashierpay/overview)
- 接受支付
- 支付后处理
- 支付方式
- 其他资源
- 高级功能
  - [预前端解决方案API](/docs/ac/cashierpay/prefront)
  - [先买后付API](/docs/ac/cashierpay/bnpl)
  - [卡存储API](/docs/ac/cashierpay/cv)
  - [卡存储SDK](/docs/ac/cashierpay/cvsdk)
  - [卡支付功能API/SDK](/docs/ac/cashierpay/mf)

快速入门
==========

本快速入门将引导您完成使用支付宝+ API的收银台支付集成过程。

设置服务器
------------

### 服务器端

（可选）添加依赖

如果您使用支付宝+ 提供的[JAR文件](https://global.alipay.com/docs/sdks)，请将其添加到您的项目中。

添加Maven依赖：
```xml
<dependency>
  <groupId>com.alipay.global.sdk
  </groupId>
  <artifactId>global-open-sdk-java</artifactId>
  <version>2.0.11</version>
</dependency>
```

配置请求
------------

请继续配置您的请求以完成与支付宝的集成。
要配置请求，请首先获取以下信息：

1. 登录[Alipay+ 控制台](https://dashboard.alipay.com/)，转到 **开发者** > **快速入门**，在 **集成资源** 部分获取以下详细信息：
   * 网关域名
   * 客户端ID
   * API密钥：您需要自己生成密钥。有关如何生成或替换密钥的更多信息，请参阅[API密钥配置](https://global.alipay.com/docs/ac/ref/key_config)。
   * API路径：在[Alipay APIs](https://global.alipay.com/docs/ac/ams/api)中获取特定API的路径。

然后将获取的网关域名、客户端ID、API密钥和API路径配置到您的API请求中。

**注意**：如果您使用Alipay+提供的JAR文件，可以直接使用代码，无需额外处理。如果您选择自己对请求签名和验证签名，请参阅[请求签名和验证签名](https://global.alipay.com/docs/ac/ams/digital_signature)。

设置HTTPS请求（Java）：

```java
String domain = "DOMAIN";
String merchantPrivateKey = "YOUR PRIVATE KEY";
String alipayPublicKey = "ALIPAY PUBLIC KEY";

AlipayClient defaultAlipayClient = new DefaultAlipayClient(
    domain, merchantPrivateKey, alipayPublicKey);

AlipayPayRequest alipayPayRequest = new AlipayPayRequest();
alipayPayRequest.setClientId(CLIENT_ID);
alipayPayRequest.setPath(API_PATH);
```

创建结账页面（客户端）：

这部分文档似乎被截断了，通常会提供如何在前端生成支付页面或调用支付接口的代码示例。为了创建结账页面，您可能需要使用Alipay提供的JavaScript SDK或者按照Alipay文档中指定的步骤，将后端生成的支付参数传递给前端，然后在用户浏览器中展示支付页面。请参考Alipay文档以获取完整步骤。
创建一个客户端结账页面，展示商品ID、订单信息、可用支付方式、支付按钮以及其他支付相关信息。

添加支付方式：

在结账页面上添加支付方式：

1. 名称：参考[支付方式](https://global.alipay.com/docs/ac/ref/payment_method#xm58z)以获取正确的支付方式名称。
2. 标志：使用[品牌资产](https://global.alipay.com/docs/ac/ref/brandasset)获取支付方式的标志。

**注意**：对于Alipay+支付方式，必须按照图片所示显示Alipay+合作伙伴标志。

Alipay+支付方式的显示：

![图片3：快速入门](https://mdn.alipayobjects.com/huamei_qg1e8t/afts/img/A*IqCYRK88mIYAAAAAAAAAAAAADsKHAQ/original)

发起支付：

服务器端：

当发起[**pay**](https://global.alipay.com/docs/ac/ams/payment_cashier)请求时，需要提供以下URL：

1. _paymentRedirectUrl_：您的支付结果页面URL。支付完成后，Alipay+会将买家重定向到此URL。根据不同的客户端终端类型，传递所需的重定向URL类型：
	* Web：传递PC网站重定向URL。
	* WAP：传递网页URL重定向URL。
	* App：传递深度链接URL。
2. _paymentNotifyUrl_：支付和捕获达到最终状态后，Alipay+会将支付和捕获结果发送到此URL。请将_paymentNotifyUrl_设置为HTTPS URL，并确保URL可以接收通知。

买家点击支付按钮后，使用在“配置请求”步骤中创建的_alipayPayRequest_对象发起**pay**请求。

根据以下不同的支付类型，参考代码编辑器中的示例：

1. **非卡支付**：包括以下支付方法类别：
	* Alipay+
	* 钱包
	* 网上银行
	* 银行转账
	* 手机银行应用
*   **信用卡支付（托管支付页面模式）**: 在这种模式下，Alipay+ 提供一个页面来收集信用卡支付信息。如果买家选择在页面上保存卡片，Alipay+ 会存储买家的卡信息并生成对应的卡令牌（_cardToken_）。你可以使用这个卡令牌进行未来的支付。
*   **信用卡支付（服务器到服务器模式）**: 这种模式要求你已通过 PCI 认证。
此外，对于信用卡支付，当你发送 **pay** 请求时，你可以根据业务需求选择是否使用[增值服务](https://global.alipay.com/docs/ac/cashierpay/value_added)。
对于不同支付方式的具体支付要求，参见 **pay** API。
订单信息：
Java
```java
// 设置订单信息
Order order = new Order();
// 用你的订单ID替换
String orderId = UUID.randomUUID().toString();
order.setReferenceOrderId(orderId);
order.setOrderDescription("测试订单");
order.setOrderAmount(amount);
Buyer buyer = new Buyer();
buyer.setReferenceBuyerId("你的买家ID");
order.setBuyer(buyer);
order.setOrderAmount(amount);
alipayPayRequest.setOrder(order);
```
环境信息：
Java
```java
// 设置环境信息
Env env = new Env();
env.setTerminalType("WEB");
env.setClientIp("你的客户IP");
alipayPayRequest.setEnv(env);
order.setEnv(env);
```
请注意，以上代码示例是假设使用 Java 语言，并且是简化版，实际应用中可能需要包含更多的错误处理和配置细节。
支付信息：

非卡支付
卡支付（托管支付页面模式）
卡支付（服务器到服务器模式）

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

// 设置金额
Amount amount = new Amount();
amount.setCurrency("BRL");
amount.setValue("4200");
alipayPayRequest.setPaymentAmount(amount);

// 设置结算货币
SettlementStrategy settlementStrategy = new SettlementStrategy();
settlementStrategy.setSettlementCurrency("USD");
alipayPayRequest.setSettlementStrategy(settlementStrategy);

// 用你的paymentRequestId替换
String paymentRequestId = UUID.randomUUID().toString();
alipayPayRequest.setPaymentRequestId(paymentRequestId);

// 设置支付方式
PaymentMethod paymentMethod = new PaymentMethod();
paymentMethod.setPaymentMethodType("GCASH");
alipayPayRequest.setPaymentMethod(paymentMethod);

// 设置产品代码
alipayPayRequest.setProductCode("CASHIER_PAYMENT");

请注意，上述代码示例是用Java编写的，用于设置支付宝支付请求。金额设置为4200巴西雷亚尔（BRL），结算货币设置为美元（USD），paymentRequestId是随机生成的UUID，支付方式设为GCASH，产品代码表示是收银台支付。
卡片信息（服务器到服务器模式）：

Java

```java
// 如果商家收集卡片信息，将卡片信息设置在此
Map<String, Object> paymentMethodMetaData = new HashMap<String, Object>();
paymentMethodMetaData.put("cardNo", "0255187751531899");
paymentMethodMetaData.put("cvv", "712");
paymentMethodMetaData.put("expiryMonth", "06");
paymentMethodMetaData.put("expiryYear", "28");
paymentMethodMetaData.put("tokenize", false);

JSONObject cardholderName = new JSONObject();
cardholderName.put("firstName", "Alan");
cardholderName.put("lastName", "Wallex");
paymentMethodMetaData.put("cardholderName", cardholderName);

paymentMethod.setPaymentMethodMetaData(paymentMethodMetaData);
```

卡片授权（卡片支付）：

Java

```java
// 设置授权
paymentFactor.setAuthorization(true);
alipayPayRequest.setPaymentFactor(paymentFactor);
```

请注意，上述代码示例是用于处理卡片信息和授权的Java代码片段。在服务器到服务器模式下，商家可以收集并存储卡片信息，然后设置授权以进行卡片支付。在示例中，`paymentMethodMetaData` 用于存储卡片详细信息，包括卡号、安全码、过期月和年，以及是否标记化。`paymentFactor` 对象用于设置授权支付的标志。
支付重定向URL设置：

Java代码示例：
```java
// 替换为你的重定向URL
alipayPayRequest.setPaymentRedirectUrl("http://www.yourRedirectUrl.com");
```

支付通知URL设置：

Java代码示例：
```java
// 替换为你的通知URL
alipayPayRequest.setPaymentNotifyUrl("http://www.yourNotifyUrl.com");
```

请求签名：

Java代码示例：
```java
// 初始化签名工具类
AlipaySignature alipaySignature = new AlipaySignature(RSACoder.getRsa256Signer(privateKey));

// 设置请求参数
Map<String, String> params = new HashMap<>();
params.put("param1", "value1");
params.put("param2", "value2");

// 添加业务签名参数
params.put("sign_type", "RSA2");
params.put("sign", "");

// 对参数进行排序并签名
String sortedParamString = AlipaySignature.rsa256SortAndSign(params, alipaySignature);

// 将签名后的参数发送给支付宝
sendToAlipay(sortedParamString);
```
请注意，这里的`privateKey`应替换为你的私钥，`sendToAlipay`是发送签名后参数到支付宝的自定义方法。
```java
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
private String genSignValue(String httpMethod, String path, String clientId, String requestTime, String reqBody) throws AlipayApiException {
    String signatureValue;
    try {
        String reqContent = httpMethod + " " + path + "\\n" + clientId + "." + requestTime + "." + reqBody;
        signatureValue = encode(signWithSHA256RSA(reqContent, merchantPrivateKey), DEFAULT_CHARSET);
    } catch (Exception e) {
        throw new AlipayApiException(e);
    }
    return signatureValue;
}

/**  
 * 使用发送者的私钥生成Base64编码的签名  
 *  
 * @param reqContent: 需要由发送者签名的原始内容  
 * @param strPrivateKey: 应该是Base64编码的私钥  
 * @return  
 * @throws Exception  
 */
private static String signWithSHA256RSA(String reqContent, String strPrivateKey) throws Exception {
    Signature privateSignature = Signature.getInstance(SHA256WITHRSA);
    privateSignature.initSign(getPrivateKeyFromBase64String(strPrivateKey));
    privateSignature.update(reqContent.getBytes(DEFAULT_CHARSET));
    byte[] s = privateSignature.sign();
    return base64Encryptor.encodeToString(s);
}

/**  
 * URL编码  
 *  
 * @param originalStr  
 * @param characterEncoding  
 * @return  
 * @throws UnsupportedEncodingException  
 */
private static String encode(String originalStr, String characterEncoding) throws UnsupportedEncodingException {
    return URLEncoder.encode(originalStr, characterEncoding);
}

/**  
 * 生成必需的头部信息  
 *  
 * @param requestTime 请求时间  
 * @param clientId 客户端ID  
 * @param keyVersion 密钥版本  
 * @param signatureValue 签名值  
 * @return  
 */
private Map<String, String> buildBaseHeader(String requestTime, String clientId, Integer keyVersion, String signatureValue) {
```

请注意，这个代码片段是Java代码，它定义了几个方法，用于生成签名值、使用SHA256RSA算法签名原始内容以及URL编码字符串。这些方法通常用于金融交易或API请求的安全认证。`genSignValue`方法用于生成签名值，`signWithSHA256RSA`用于使用私钥签名，`encode`用于URL编码，`buildBaseHeader`用于构建请求头。
```java
Map<String, String> header = new HashMap<String, String>();
header.put("Content-Type", "application/json; charset=UTF-8");
header.put("Request-Time", requestTime);
header.put("client-id", clientId);
if (keyVersion == null) {
    keyVersion = DEFULT_KEY_VERSION;
}
String signatureHeader = "algorithm=RSA256,keyVersion=" + keyVersion + ",signature=" + signatureValue;
header.put(Signature, signatureHeader);
return header;
```

处理支付结果

客户端与服务器端

支付响应（客户端）

当从支付宝+接收到**pay**响应时，根据_result.resultStatus_的值处理支付结果：

-   _result.resultStatus_=`S`：表示支付成功。向买家展示支付成功的结果。
-   _result.resultStatus_=`F`：表示支付失败。向买家展示支付失败的结果。
-   _result.resultStatus_=`U`：表示支付处理中。将买家重定向到支付宝+返回的URL。

处理重定向URL

当_result.resultStatus_的值为`U`时，会返回至少一个以下URL：

-   _normalUrl_：HTTPS地址的URL，用于在您的网站的同一浏览器页面上将买家重定向到支付方式的网站页面。请注意，此URL可能包含一个调用支付方式应用的按钮。
-   _schemeUrl_：用于打开支付方式应用的方案URL。
*   _applinkUrl_: 用于支付过程中重定向的Android App Link或iOS Universal Link。  
根据不同的终端类型（Web、WAP和App）和操作系统（iOS和Android）处理URL。  
**Web**: 买家在您的PC网站上下单。  
JavaScript  
1  
2  
3  
如果 (serverResponse.normalUrl) {  
window.open(serverResponse  
.normalUrl, '\_blank');  
}  
**WAP**: 买家在您的移动浏览器网站上下单。  
JavaScript  
1  
2  
3  
4  
5  
6  
7  
如果 (serverResponse.applinkUrl) {  
window.location.href =  
serverResponse.applinkUrl;  
} else if (serverResponse  
.normalUrl) {  
window.location.href =  
serverResponse.normalUrl;  
} else if (serverResponse  
.redirectActionForm  
.redirectUrl) {  
window.location.href =  
serverResponse  
.redirectActionForm  
.redirectUrl;  
}  
**App（iOS）**: 买家在您的iOS App上下单。  
Objective-C  
1  
2  
3  
4  
5  
如果 ([[[UIDevice currentDevice]
系统版本号：[[UIApplication sharedApplication] systemVersion] floatValue]  
大于等于10.0时：  
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:Url] options:@{} completionHandler:nil];  
否则：  
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:Url]];  

安卓应用：买家从您的安卓应用下单。  
Java  
1  
2  
3  
4  
5  
6  
7  
8  
try {  
Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(Url));  
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);  
// 使用startActivity函数重定向到钱包应用  
startActivity(intent);  
} catch (Exception e) {  
e.printStackTrace();  
}  

异步通知（服务器端）  
当支付状态最终成功或失败时，支付宝+会向您通过**pay** API 提供的_paymentNotifyUrl_发送异步通知。请确保该URL能够接收到通知。
当您收到支付结果通知时，请按照以下步骤处理：

1. 验证通知。
2. 更新您的订单状态。
3. 根据代码编辑器中显示的固定格式向支付宝+发送通知响应。您不需要对响应进行签名。

验证通知：

Java

```java
// 检查响应签名的方法
private boolean checkRspSign(String httpMethod, String path, String clientId, String responseTime, String rspBody, String rspSignValue) throws AlipayApiException {
    try {
        String rspContent = httpMethod + " " + path + "\n" + clientId + "." + responseTime + "." + rspBody;
        return verifySignatureWithSHA256RSA(rspContent, decode(signature, DEFAULT_CHARSET), alipayPublicKey);
    } catch (Exception e) {
        throw new AlipayApiException(e);
    }
}

/**
 * 验证接收的签名是否使用发送者的公钥正确生成
 * 
 * @param rspContent: 发送者签名并由接收者验证的原始内容
 * @param signature: 发送者生成的签名
 * @param strPk: 发送者的公钥（Base64编码字符串）
 * @return
 * @throws Exception
 */
private static boolean verifySignatureWithSHA256RSA(String rspContent, String signature, String strPk) throws Exception {
    PublicKey publicKey = getPublicKeyFromBase64String(strPk);
    Signature publicSignature = Signature.getInstance(SHA256WITHRSA);
    publicSignature.initVerify(publicKey);
    publicSignature.update(rspContent.getBytes(DEFAULT_CHARSET));
    byte[] signatureBytes = base64Encryptor.decode(signature);
    return publicSignature.verify(signatureBytes);
}

/**
 * URL解码
 * 
 * @param originalStr
 * @param characterEncoding
```

请注意，这个Java代码片段中缺少了`getPublicKeyFromBase64String`方法和`base64Encryptor`对象的定义，这些是用于处理公钥和Base64编码的辅助方法。在实际应用中，您需要提供这些实现。
\* @return  
\* @throws  
UnsupportedEncodingException  
\*/  
private static String decode(String originalStr, String characterEncoding) throws UnsupportedEncodingException {  
return URLDecoder.decode(originalStr, characterEncoding);  
}  

翻译成中文：

\* @return  
\* @throws  
UnsupportedEncodingException  
\*/  
private static String 解码(String 原始字符串, String 字符编码) throws UnsupportedEncodingException {  
return URLDecoder.decode(originalStr, characterEncoding);  
}  

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

通知响应：  
JSON

1  
2  
3  
4  
5  
6  
7  
{  
"result": {  
"resultCode": "SUCCESS",  
"resultStatus": "S",  
"resultMessage": "Success"  
}  
}  

翻译成中文：

通知响应：  
JSON

1  
2  
3  
4  
5  
6  
7  
{  
"result": {  
"resultCode": "成功",  
"resultStatus": "S",  
"resultMessage": "成功"  
}  
}  

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

处理扣款结果通知  
服务器端  
在买家完成卡授权支付后，Alipay+ 会自动为您扣款。当扣款状态最终成功或失败时，Alipay+ 会向您发送异步通知。确保通过 **pay** API 提供的 _paymentNotifyUrl_ 能够接收通知。

当您收到扣款结果通知时，按照以下步骤处理：

1. 验证通知。
2. 更新您的订单状态。
3. 向支付宝+发送通知响应，遵循代码编辑器中所示的固定格式。无需对响应进行签名。

验证通知：

Java

```java
// 检查响应签名的方法
private boolean checkRspSign(String httpMethod, String path, String clientId, String responseTime, String rspBody, String rspSignValue) throws AlipayApiException {
    try {
        String rspContent = httpMethod + " " + path + "\n" + clientId + "." + responseTime + "." + rspBody;
        return verifySignatureWithSHA256RSA(rspContent, decode(signature, DEFAULT_CHARSET), alipayPublicKey);
    } catch (Exception e) {
        throw new AlipayApiException(e);
    }
}

/**
 * 验证接收的签名是否使用发送者的公钥正确生成
 *
 * @param rspContent: 发送者签名并由接收者验证的原始内容
 * @param signature: 发送者生成的签名
 * @param strPk: 发送者的公钥（Base64编码）
 * @return
 * @throws Exception
 */
private static boolean verifySignatureWithSHA256RSA(String rspContent, String signature, String strPk) throws Exception {
    PublicKey publicKey = getPublicKeyFromBase64String(strPk);
    Signature publicSignature = Signature.getInstance(SHA256WITHRSA);
    publicSignature.initVerify(publicKey);
    publicSignature.update(rspContent.getBytes(DEFAULT_CHARSET));
    byte[] signatureBytes = base64Encryptor.decode(signature);
    return publicSignature.verify(signatureBytes);
}

/**
 * URL解码
 *
 * @param originalStr
 * @param characterEncoding
 * @return
 * @throws UnsupportedEncodingException
 */
private static String decode(String originalStr, String characterEncoding) throws UnsupportedEncodingException {
    return URLDecoder.decode(originalStr, characterEncoding);
}
```

这段代码是用于验证从支付宝+接收到的通知响应的签名是否有效。`checkRspSign`方法组合了请求的各个部分以生成响应内容，然后使用`verifySignatureWithSHA256RSA`方法和支付宝的公钥来验证签名。如果签名验证成功，说明响应是有效的。`decode`方法用于对URL编码的字符串进行解码。
```java
 throws  
UnsupportedEncodingException {  
return URLDecoder.decode(originalStr, characterEncoding);  
}
```

这段Java代码尝试使用`URLDecoder.decode`方法对原始字符串`originalStr`进行解码，使用的字符编码是`characterEncoding`。如果指定的字符编码不受支持，它会抛出一个`UnsupportedEncodingException`。

---

通知响应：

```json
{
  "result": {
    "resultCode": "SUCCESS",
    "resultStatus": "S",
    "resultMessage": "Success"
  }
}
```

这是一个JSON响应，表示结果成功。`resultCode`为"SUCCESS"，`resultStatus`为"S"，`resultMessage`表明操作成功。

---

#### 这个页面有帮助吗？

要查看文档的最新更新，请访问[发布说明](https://global.alipay.com/docs/releasenotes)。

![Image 4](https://ac.alipay.com/storage/2021/5/20/19b2c126-9442-4f16-8f20-e539b1db482a.png) ![Image 5](https://ac.alipay.com/storage/2021/5/20/e9f3f154-dbf0-455f-89f0-b3d4e0c14481.png)

@2024 蚂蚁金服 [法律信息](https://global.alipay.com/docs/ac/platform/membership)
```