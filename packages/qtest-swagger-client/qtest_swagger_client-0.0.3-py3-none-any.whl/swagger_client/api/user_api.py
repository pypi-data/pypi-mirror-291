# coding: utf-8

"""
    qTest Manager API Version 11.0.0 - 2023.6

    qTest Manager API Version 11.0.0 - 2023.6  # noqa: E501

    OpenAPI spec version: 11.0.0 - 2023.6
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class UserApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def assign_to_project(self, user_id, body, **kwargs):  # noqa: E501
        """Assigns a User to a Project  # noqa: E501

        To assign a User to a Project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_to_project(user_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: ID of the user. (required)
        :param AssignedProject body: The project ID and the assigned user profile in the project. If the profile is not provided, profile Developer is used by default (required)
        :return: AssignedProject
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.assign_to_project_with_http_info(user_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.assign_to_project_with_http_info(user_id, body, **kwargs)  # noqa: E501
            return data

    def assign_to_project_with_http_info(self, user_id, body, **kwargs):  # noqa: E501
        """Assigns a User to a Project  # noqa: E501

        To assign a User to a Project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_to_project_with_http_info(user_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: ID of the user. (required)
        :param AssignedProject body: The project ID and the assigned user profile in the project. If the profile is not provided, profile Developer is used by default (required)
        :return: AssignedProject
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_to_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `assign_to_project`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `assign_to_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{userId}/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AssignedProject',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def assign_users_to_project(self, body, **kwargs):  # noqa: E501
        """Assigns multiple Users to a Project  # noqa: E501

        To assign a list of Users to a Project  <strong>qTest Manager version:</strong> 4+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_users_to_project(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AssignedUsersProject body: ID of the Project and an array of assigned Users' IDs. If the profile is not provided, Developer profile is used by default (required)
        :return: AssignedUsersProject
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.assign_users_to_project_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.assign_users_to_project_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def assign_users_to_project_with_http_info(self, body, **kwargs):  # noqa: E501
        """Assigns multiple Users to a Project  # noqa: E501

        To assign a list of Users to a Project  <strong>qTest Manager version:</strong> 4+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_users_to_project_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AssignedUsersProject body: ID of the Project and an array of assigned Users' IDs. If the profile is not provided, Developer profile is used by default (required)
        :return: AssignedUsersProject
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_users_to_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `assign_users_to_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AssignedUsersProject',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user(self, body, **kwargs):  # noqa: E501
        """Invites a User  # noqa: E501

        To invite a user to your qTest Manager instance and activate the account. If the password is omitted, the default \"<em>admin123</em>\" will be used  <strong>qTest Manager version:</strong> 4+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserResource body: Invited user's information  <em>username (require)</em>: email of new user  <em>email</em>: recovery email of new user  <em>password</em>: password of new user. If the password is omitted, the default \"admin123\" will be used  <em>first_name (require)</em>: First name of new user  <em>last_name (require)</em>: Last name of new user  <em>user_group_ids</em>: List usergroup ids will be assigned for new user.  <em>send_activation_email</em>: activation email will be ignored if this is set to <strong>false</strong>. Default value is <strong>false</strong>  <em>external_auth_config_id</em>: auto assign this new user with External Authentication system by this providing config id here. If this value is provided, <em>\"external_user_name\"</em> need to have value, or it will failed to create.  <em>external_user_name</em>: external username that will be assigned to newly created qTest user   <em>include_default_groups</em>:Include default groups or not. Default value is <strong>false</strong> (required)
        :return: UserResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_user_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_user_with_http_info(self, body, **kwargs):  # noqa: E501
        """Invites a User  # noqa: E501

        To invite a user to your qTest Manager instance and activate the account. If the password is omitted, the default \"<em>admin123</em>\" will be used  <strong>qTest Manager version:</strong> 4+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserResource body: Invited user's information  <em>username (require)</em>: email of new user  <em>email</em>: recovery email of new user  <em>password</em>: password of new user. If the password is omitted, the default \"admin123\" will be used  <em>first_name (require)</em>: First name of new user  <em>last_name (require)</em>: Last name of new user  <em>user_group_ids</em>: List usergroup ids will be assigned for new user.  <em>send_activation_email</em>: activation email will be ignored if this is set to <strong>false</strong>. Default value is <strong>false</strong>  <em>external_auth_config_id</em>: auto assign this new user with External Authentication system by this providing config id here. If this value is provided, <em>\"external_user_name\"</em> need to have value, or it will failed to create.  <em>external_user_name</em>: external username that will be assigned to newly created qTest user   <em>include_default_groups</em>:Include default groups or not. Default value is <strong>false</strong> (required)
        :return: UserResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserResource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_by_user_name_or_email(self, **kwargs):  # noqa: E501
        """Queries Users by Username  # noqa: E501

        To query for users by their username  <strong>qTest Manager version:</strong> 8.4.2+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_user_name_or_email(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: API will return users which have been added to projects whose names contain the text specified in this parameter.  Login names of users should be provided for this query, but they vary based on the source of the user.  - qTest Login Email - for users created directly on qTest  - LDAP or SSO username or external username - for users created from LDAP or SSO
        :param bool include_inactive_users: <em>includeInactiveUsers=false</em> - default value. Inactive users are excluded from the response  <em>includeInactiveUsers=true</em> - inactive users are included in the response
        :param bool pagination: <em>pagination=true</em> - default value. The result is paginated  <em>pagination=false</em> - the result is not paginated
        :param list[int] auth_system_config_ids: LDAP Configuration Ids
        :param int page: By default the first page is returned but you can specify any page number to retrieve objects
        :param int page_size: The result is paginated. By the default, the number of objects in each page is 100 if this is omitted. You can specify your custom number (up to 100) in this parameter.
        :return: SearchUserResourceExtensionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_by_user_name_or_email_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_by_user_name_or_email_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_by_user_name_or_email_with_http_info(self, **kwargs):  # noqa: E501
        """Queries Users by Username  # noqa: E501

        To query for users by their username  <strong>qTest Manager version:</strong> 8.4.2+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_user_name_or_email_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: API will return users which have been added to projects whose names contain the text specified in this parameter.  Login names of users should be provided for this query, but they vary based on the source of the user.  - qTest Login Email - for users created directly on qTest  - LDAP or SSO username or external username - for users created from LDAP or SSO
        :param bool include_inactive_users: <em>includeInactiveUsers=false</em> - default value. Inactive users are excluded from the response  <em>includeInactiveUsers=true</em> - inactive users are included in the response
        :param bool pagination: <em>pagination=true</em> - default value. The result is paginated  <em>pagination=false</em> - the result is not paginated
        :param list[int] auth_system_config_ids: LDAP Configuration Ids
        :param int page: By default the first page is returned but you can specify any page number to retrieve objects
        :param int page_size: The result is paginated. By the default, the number of objects in each page is 100 if this is omitted. You can specify your custom number (up to 100) in this parameter.
        :return: SearchUserResourceExtensionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'include_inactive_users', 'pagination', 'auth_system_config_ids', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_by_user_name_or_email" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'include_inactive_users' in params:
            query_params.append(('includeInactiveUsers', params['include_inactive_users']))  # noqa: E501
        if 'pagination' in params:
            query_params.append(('pagination', params['pagination']))  # noqa: E501
        if 'auth_system_config_ids' in params:
            query_params.append(('authSystemConfigIds', params['auth_system_config_ids']))  # noqa: E501
            collection_formats['authSystemConfigIds'] = 'multi'  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchUserResourceExtensionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_users_by_projects_name(self, **kwargs):  # noqa: E501
        """Queries Users by Project Name  # noqa: E501

        To query for users by names of their assigned projects  - Admin users with <em>Manage Client Users</em> permission can query users in any projects  - For other users: the API only returns users within projects to which the requesting user is assigned  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_users_by_projects_name(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_name: Name of the project whose users you want to query for. The API will return users which have been added to projects whose names contain the text specified in this parameter  <strong>IMPORTANT:</strong> Project name is case sensitive
        :param bool inactive: <em>inactive=false</em> - default value. Inactive users are excluded from the response  <em>inactive=true</em> - include inactive users
        :param bool pagination: <em>pagination=true</em> - default value. The result is paginated  <em>pagination=false</em> - the result is not paginated
        :param int page: By default the first page is returned but you can specify any page number to retrieve objects
        :param int page_size: The result is paginated. By the default, the number of objects in each page is 100 if this is omitted. You can specify your custom number (up to 999) in this parameter
        :return: SearchUserResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_users_by_projects_name_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_users_by_projects_name_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_users_by_projects_name_with_http_info(self, **kwargs):  # noqa: E501
        """Queries Users by Project Name  # noqa: E501

        To query for users by names of their assigned projects  - Admin users with <em>Manage Client Users</em> permission can query users in any projects  - For other users: the API only returns users within projects to which the requesting user is assigned  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_users_by_projects_name_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_name: Name of the project whose users you want to query for. The API will return users which have been added to projects whose names contain the text specified in this parameter  <strong>IMPORTANT:</strong> Project name is case sensitive
        :param bool inactive: <em>inactive=false</em> - default value. Inactive users are excluded from the response  <em>inactive=true</em> - include inactive users
        :param bool pagination: <em>pagination=true</em> - default value. The result is paginated  <em>pagination=false</em> - the result is not paginated
        :param int page: By default the first page is returned but you can specify any page number to retrieve objects
        :param int page_size: The result is paginated. By the default, the number of objects in each page is 100 if this is omitted. You can specify your custom number (up to 999) in this parameter
        :return: SearchUserResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_name', 'inactive', 'pagination', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_users_by_projects_name" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_name' in params:
            query_params.append(('projectName', params['project_name']))  # noqa: E501
        if 'inactive' in params:
            query_params.append(('inactive', params['inactive']))  # noqa: E501
        if 'pagination' in params:
            query_params.append(('pagination', params['pagination']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/search/user', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchUserResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_avatar(self, user_id, **kwargs):  # noqa: E501
        """Gets a User's Avatar  # noqa: E501

        To retrieve a User's Avatar  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_avatar(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: ID of the user. (required)
        :return: OutputStream
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_avatar_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_avatar_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_avatar_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Gets a User's Avatar  # noqa: E501

        To retrieve a User's Avatar  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_avatar_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: ID of the user. (required)
        :return: OutputStream
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_avatar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `get_avatar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{userId}/avatar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OutputStream',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_by_id(self, user_id, **kwargs):  # noqa: E501
        """Gets a User  # noqa: E501

        To retrieve a User's information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_by_id(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: ID of the user. (required)
        :return: UserResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_by_id_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_by_id_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_user_by_id_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Gets a User  # noqa: E501

        To retrieve a User's information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_by_id_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: ID of the user. (required)
        :return: UserResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{userId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserResource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reevaluate_token(self, **kwargs):  # noqa: E501
        """Gets current user's information  # noqa: E501

        To retrieve your information such as username, email, first name, and last name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reevaluate_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_inaccessible_apps:
        :return: LoggedUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reevaluate_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.reevaluate_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def reevaluate_token_with_http_info(self, **kwargs):  # noqa: E501
        """Gets current user's information  # noqa: E501

        To retrieve your information such as username, email, first name, and last name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reevaluate_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_inaccessible_apps:
        :return: LoggedUser
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_inaccessible_apps']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reevaluate_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_inaccessible_apps' in params:
            query_params.append(('includeInaccessibleApps', params['include_inaccessible_apps']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/re-evaluation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoggedUser',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_association_users_and_projects(self, body, **kwargs):  # noqa: E501
        """Remove association between users and projects  # noqa: E501

        To remove association between users and projects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_association_users_and_projects(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ProjectWithUserIdsObject] body: An array of pairs project_id and user_ids   <em>project_id:</em> ID of the project  <em>user_ids: </em> List of User IDs which are being removed from the project (required)
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_association_users_and_projects_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_association_users_and_projects_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def remove_association_users_and_projects_with_http_info(self, body, **kwargs):  # noqa: E501
        """Remove association between users and projects  # noqa: E501

        To remove association between users and projects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_association_users_and_projects_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ProjectWithUserIdsObject] body: An array of pairs project_id and user_ids   <em>project_id:</em> ID of the project  <em>user_ids: </em> List of User IDs which are being removed from the project (required)
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_association_users_and_projects" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `remove_association_users_and_projects`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/projects', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, user_id, body, **kwargs):  # noqa: E501
        """Update user's information  # noqa: E501

        To update information of a user, like : recovery email, password, status...  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user(user_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: ID of the user. (required)
        :param UserUpdateResource body: Update user's information  <em>email</em>: New recovery email of user  <em>password</em>: New password of user. Password have to map with password policy of current user's client  <em>first_name</em>: New first name of user  <em>last_name</em>: New last name of user  <em>user_group_ids</em>: List usergroup ids will be assigned for user (old usergroup ids will be replaced).  <em>external_auth_config_id</em>: New user's external authenticate id,it will auto assign this user with External Authentication system by this providing config id here. If this value is provided, <em>\"external_user_name\"</em> need to have value, or it will failed to update. For internal authentication system input : <strong>-1</strong>  <em>external_user_name</em>: external username that will be assigned to user (if LDAP external is specified, \"first_name\" and \"last_name\" will be fetch from LDAP system).  <em>status</em>: New status id of user. Status id must be <strong>1</strong> for Active or <strong>3</strong> for Inactive status. (required)
        :return: UserResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_with_http_info(user_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_with_http_info(user_id, body, **kwargs)  # noqa: E501
            return data

    def update_user_with_http_info(self, user_id, body, **kwargs):  # noqa: E501
        """Update user's information  # noqa: E501

        To update information of a user, like : recovery email, password, status...  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_with_http_info(user_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: ID of the user. (required)
        :param UserUpdateResource body: Update user's information  <em>email</em>: New recovery email of user  <em>password</em>: New password of user. Password have to map with password policy of current user's client  <em>first_name</em>: New first name of user  <em>last_name</em>: New last name of user  <em>user_group_ids</em>: List usergroup ids will be assigned for user (old usergroup ids will be replaced).  <em>external_auth_config_id</em>: New user's external authenticate id,it will auto assign this user with External Authentication system by this providing config id here. If this value is provided, <em>\"external_user_name\"</em> need to have value, or it will failed to update. For internal authentication system input : <strong>-1</strong>  <em>external_user_name</em>: external username that will be assigned to user (if LDAP external is specified, \"first_name\" and \"last_name\" will be fetch from LDAP system).  <em>status</em>: New status id of user. Status id must be <strong>1</strong> for Active or <strong>3</strong> for Inactive status. (required)
        :return: UserResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `update_user`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/users/{userId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserResource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
