from collections.abc import Callable, Sequence
from typing import Annotated, overload

from numpy.typing import ArrayLike


class ChebyshevCollection:
    def __init__(self, arg: Sequence[ChebyshevExpansion], /) -> None: ...

    def __call__(self, arg: float, /) -> float: ...

    def y_unsafe(self, arg: float, /) -> float: ...

    def integrate(self, arg0: float, arg1: float, /) -> float: ...

    def get_xmin(self) -> float: ...

    def get_xmax(self) -> float: ...

    def get_exps(self) -> list[ChebyshevExpansion]: ...

    def get_extrema(self) -> list[float]: ...

    def solve_for_x(self, arg: float, /) -> list[float]: ...

    def make_inverse(self, N: int, xmin: float, xmax: float, M: int, tol: float, max_refine_passes: int, assume_monotonic: bool = False, unsafe_evaluation: bool = False) -> ChebyshevCollection: ...

    def get_index(self, arg: float, /) -> int: ...

    def get_hinted_index(self, arg0: float, arg1: int, /) -> int: ...

class ChebyshevExpansion:
    def __init__(self, arg0: Sequence[float], arg1: float, arg2: float, /) -> None: ...

    @overload
    def __add__(self, arg: ChebyshevExpansion, /) -> ChebyshevExpansion: ...

    @overload
    def __add__(self, arg: float, /) -> ChebyshevExpansion: ...

    def __iadd__(self, arg: ChebyshevExpansion, /) -> ChebyshevExpansion: ...

    def __sub__(self, arg: float, /) -> ChebyshevExpansion: ...

    @overload
    def __mul__(self, arg: float, /) -> ChebyshevExpansion: ...

    @overload
    def __mul__(self, arg: ChebyshevExpansion, /) -> ChebyshevExpansion: ...

    def __rmul__(self, arg: float, /) -> ChebyshevExpansion: ...

    def __imul__(self, arg: float, /) -> ChebyshevExpansion: ...

    def __neg__(self) -> ChebyshevExpansion: ...

    def times_x(self) -> ChebyshevExpansion: ...

    def times_x_inplace(self) -> ChebyshevExpansion: ...

    def apply(self, arg: Callable[[Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]], Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]], /) -> ChebyshevExpansion: ...

    def coef(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    def companion_matrix(self, arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='F')]: ...

    @overload
    def y(self, arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @overload
    def y(self, arg: float, /) -> float: ...

    def y_Clenshaw(self, arg: float, /) -> float: ...

    def real_roots(self, arg: bool, /) -> list[float]: ...

    def real_roots2(self, arg: bool, /) -> list[float]: ...

    def real_roots_UH(self, arg: bool, /) -> list[float]: ...

    def real_roots_time(self, arg: int, /) -> float: ...

    def real_roots_approx(self, arg: int, /) -> list[float]: ...

    def is_monotonic(self) -> bool: ...

    def has_real_roots_Descartes(self, arg: float, /) -> bool: ...

    def to_monomial_increasing(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    def subdivide(self, arg0: int, arg1: int, /) -> list[ChebyshevExpansion]: ...

    def real_roots_intervals(self, arg: bool, /) -> list[float]: ...

    def deriv(self, arg: int, /) -> ChebyshevExpansion: ...

    def integrate(self, arg: int, /) -> ChebyshevExpansion: ...

    def xmin(self) -> float: ...

    def xmax(self) -> float: ...

    def xmid(self) -> float: ...

    def scale_x(self, arg: float, /) -> float: ...

    def unscale_x(self, arg: float, /) -> float: ...

    def split_apart(self, arg0: float, arg1: int, arg2: bool, /) -> tuple[ChebyshevExpansion, ChebyshevExpansion]: ...

    def get_nodes_n11(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]:
        """Get the Chebyshev-Lobatto nodes in [-1,1]"""

    def get_nodes_realworld(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]:
        """Get the Chebyshev-Lobatto nodes in [xmin, xmax]"""

    def get_node_function_values(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    def cache_nodal_function_values(self, arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], /) -> None: ...

    def monotonic_solvex(self, arg: float, /) -> float: ...

def Clenshaw2DEigen(cmat: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None, None), order='None')], x: float, y: float) -> float: ...

def Clenshaw2DEigencomplex(cmat: Annotated[ArrayLike, dict(dtype='complex128', writable=False, shape=(None, None), order='None')], x: float, y: float) -> "std::__1::complex<double>": ...

def Eigen_nbThreads() -> int: ...

def Eigen_setNbThreads(arg: int, /) -> None: ...

def Schur_matrixT(arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='F')], arg1: bool, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='F')]: ...

def Schur_realeigenvalues(arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='F')], /) -> list[float]: ...

class TaylorExtrapolator:
    @overload
    def __call__(self, arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @overload
    def __call__(self, arg: float, /) -> float: ...

    def get_coef(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

def count_sign_changes(arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], arg1: float, /) -> int: ...

def dyadic_splitting(N: int, func: Callable[[float], float], xmin: float, xmax: float, M: int, tol: float, max_refine_passes: int = 8, callback: Callable[[int, Sequence[ChebyshevExpansion]], None] | None = None) -> list[ChebyshevExpansion]: ...

def eigenvalues(arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='F')], arg1: bool, /) -> Annotated[ArrayLike, dict(dtype='complex128', shape=(None), order='C')]: ...

def eigenvalues_upperHessenberg(arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='F')], arg1: bool, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

def eigs_speed_test(arg0: Sequence[int], arg1: int, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='F')]: ...

def evaluation_speed_test(arg0: ChebyshevExpansion, arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], arg2: int, /) -> "std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, double, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, double>>>": ...

def factoryfDCT(arg0: int, arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], arg2: float, arg3: float, /) -> ChebyshevExpansion: ...

def factoryfFFT(arg0: int, arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], arg2: float, arg3: float, /) -> ChebyshevExpansion: ...

def generate_Chebyshev_expansion(N: int, func: Callable[[float], float], xmin: float, xmax: float) -> ChebyshevExpansion: ...

def get_monomial_from_Cheb_basis(arg: int, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

def mult_by(arg0: ChebyshevExpansion, arg1: float, arg2: int, /) -> None: ...

def mult_by_inplace(arg0: ChebyshevExpansion, arg1: float, arg2: int, /) -> float: ...
