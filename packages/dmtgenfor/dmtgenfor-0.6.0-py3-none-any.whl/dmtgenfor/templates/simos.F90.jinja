! This an autogenerated file
! Please do not edit.
! user defined code can be added at the marked locations.
!------------------------------------------------------------------------------
!******************************************************************************
module {{type.module}}
    !---------------------------------------------------------------------------
    !use statements
    !using general modules
    !******************************************************************************
    !using general modules
    use class_string
    use iso_fortran_env, only: sp => real32, dp => real64
    use string_util
    use h5accessor_f
    use iso_c_binding, only: c_null_char, c_char
    use exceptions, only: throw, exception_occurred
    use class_io_exception, only: io_exception
    use class_illegal_state_exception, only: illegal_state_exception
    !******************************************************************************
    !using custom modules. Classes are aliased to avoid name clashing
{%- for module, dependency in type.dependencies.items() | sort(attribute='0') %}
    use {{module}}, only:        &
    {%- for imp in dependency.imports | sort(attribute='name') %}
        {%if imp.rename %}{{imp.rename}} => {%endif%}{{imp.name}}{%- if not loop.last %},        &{%-endif%}
    {%- endfor %}
{%- endfor %}
#   include "exceptions.h"
    !---------------------------------------------------------------------------
!@@@@@ USER DEFINED USE START @@@@@
{{type.user_defined.get("use", "")}}
!@@@@@ USER DEFINED USE END @@@@@
    !---------------------------------------------------------------------------
    implicit none
    private
    !---------------------------------------------------------------------------
    public :: {{type.type}}
    !> {{type.description}}
    type :: {{type.type}}{%-if type.is_shared%} ! #shared {%endif%}{%-if type.is_writable%} ! #writeable-all {%endif%}
        private
{%- for attr in type.attributes %}
        ! {{attr.description}}
        {{attr.type_init}}{%-if attr.is_shared%} ! #shared {%endif%}
        {%-if attr.is_optional %}
        logical, public :: is_set_{{attr.name}} = .false.
        {%-endif%}

{%- endfor %}
!---------------------------------------------------------------------------
!@@@@@ USER DEFINED PROPERTIES START @@@@@
{{type.user_defined.get("properties", "")}}
!@@@@@ USER DEFINED PROPERTIES END @@@@@
        contains
        private

        generic, public :: default_init => default_initFromSingle, default_initFromSingleWiNameFromChar, default_initFromSingleWiNameFromString
        procedure, public :: allocate
        generic, public :: save_hdf5 => save_hdf5_filename, save_hdf5_filename_name, save_hdf5_group_id
        generic, public :: load_HDF5 => load_HDF5_fromDefaultFile, load_HDF5_fromFileNameAndEntityName, load_HDF5_fromGroupIndex
        procedure, public :: isValid
        procedure, public :: destroy
        !--- resize functions for single atomic arrays ----
        {%- for attr in type.attributes if attr.is_variable_array %}
        procedure, public :: resize_{{attr.name}}
        {%- endfor %}
        ! Private procedures
        procedure :: default_initFromSingle
        procedure :: default_initFromSingleWiNameFromChar
        procedure :: default_initFromSingleWiNameFromString
        procedure :: save_hdf5_filename
        procedure :: save_hdf5_filename_name
        procedure :: save_hdf5_group_id
        procedure :: load_HDF5_fromDefaultFile
        procedure :: load_HDF5_fromFileNameAndEntityName
        procedure :: load_HDF5_fromGroupIndex
        {%- for attr in type.attributes if attr.is_destroyable %}
        procedure :: destroy_{{attr.name}}
        {%- endfor %}
    !---------------------------------------------------------------------------
!@@@@@ USER DEFINED PROCEDURE DECLARATIONS START @@@@@
{{type.user_defined.get("procedure", "")}}
!@@@@@ USER DEFINED PROCEDURE DECLARATIONS End   @@@@@
    end type {{type.type}}

contains
!@@@@@ USER DEFINED DECLARATIONS START @@@@@
{{type.user_defined.get("declarations", "")}}
!@@@@@ USER DEFINED DECLARATIONS END @@@@@
    pure subroutine destroy(this)
        class({{type.type}}), intent(inout) :: this
        {%- for attr in type.attributes if attr.is_destroyable%}
        call this%destroy_{{attr.name}}()
        {%- endfor %}
    end subroutine destroy

    {%for attr in type.attributes if attr.is_destroyable %}
    pure subroutine destroy_{{attr.name}}(this)
        class({{type.type}}), intent(inout) :: this
        {{attr.destroy}}
    end subroutine destroy_{{attr.name}}
    !---------------------------------------------------------------------------
    {%-endfor %}
    !-------------------------------Default initialization----------------------
    subroutine allocate(this){%-if type.is_shared%} ! #shared {%endif%}
        class({{type.type}}), intent(out) :: this

        call this%default_initFromSingle()
    end subroutine allocate

    pure subroutine default_initFromSingleWiNameFromChar(this, insName)
        class({{type.type}}), intent(inout) :: this
        character(*), intent(in) :: insName

        call this%default_initFromSingle()
        {%if type.has_name-%}
        ! Set the default name of the object
        this%name = string(insName)
	    {%-endif%}
    end subroutine default_initFromSingleWiNameFromChar

    pure subroutine default_initFromSingleWiNameFromString(this, insName)
        class({{type.type}}), intent(inout) :: this
        type(String), intent(in) :: insName

        call this%default_initFromSingle()
        {%if type.has_name-%}
        ! Set the default name of the object
        this%name = insName
	    {%-endif%}
    end subroutine default_initFromSingleWiNameFromString

    pure subroutine default_initFromSingle(this)
        class({{type.type}}), intent(inout) :: this

        {%if type.has_name-%}
		! Set the default name of the object
		this%name = string('{{type.type}}')
	    {%-endif%}
        {%-for attr in type.attributes if attr.has_default_init %}
        call this%{{attr.fieldname}}%default_init('{{attr.name}}')
        {%-endfor%}
    end subroutine default_initFromSingle

    subroutine save_hdf5_filename(this, filename, overwrite)
        implicit none
        class({{type.type}}) :: this
        !> Name of file to store object in
        type(string), intent(in) :: filename
        !> Erase data from existing file before writing new? Default: False
        logical, optional, intent(in) :: overwrite

        {%if type.has_name-%}
        call this%save_hdf5(filename, this%name, overwrite)
	    {%-else%}
        call this%save_hdf5(filename, string('{{type.name}}'), overwrite)
	    {%-endif%}
        if (exception_occurred()) return
    end subroutine


    subroutine save_hdf5_filename_name(this, filename, name, overwrite)
        implicit none
        class({{type.type}}) :: this
        !> Name of file to store object in
        type(string), intent(in) :: filename
        !> Name of object on file
        type(string), intent(in) :: name
        !> Erase data from existing file before writing new? Default: False
        logical, optional, intent(in) :: overwrite
        ! Internal variables
        type(string) :: error_message
        logical :: exists
        logical :: is_overwrite
        integer :: dataBaseID, groupID, errorj
        integer :: i, n
        character(kind=c_char), allocatable :: cchars(:)
        character(len=:), allocatable :: fileFormat

        is_overwrite = .false.
        if (present(overwrite)) is_overwrite = overwrite

        if (.not. this%isValid()) then
            error_message = 'Cannot save model that is not valid'
            call throw(illegal_state_exception(error_message))
            end if
        ! Initialization
        errorj=0
        call h5a_initialize('no config required')

                inquire(file=filename%to_chars(), exist=exists)
        if (exists .and. is_overwrite) then
            errorj = H5A_RemoveDatabase(filename%to_c_chars())
            if (H5A_IS_ERROR(errorj)) then
                error_message = 'Failed to remove existing file ' + filename
                call throw(io_exception(error_message))
                return
            end if
        end if

        dataBaseID = H5A_OpenOrCreateDatabase(filename%to_c_chars())
        if (H5A_IS_ERROR(dataBaseID)) then
            error_message = 'Failed to create file ' + filename
            call throw(io_exception(error_message))
            return
        end if

        ! Save the current object
        if (.not. exists .or. is_overwrite) then
            ! Specify file format
            errorj = H5A_SetFormat(dataBaseID, 'simos_r0' // c_null_char)
            if (H5A_IS_ERROR(errorj)) then
                error_message = 'Failed to set format of file'
                call throw(io_exception(error_message))
                return
            end if
        else
            ! Verify format
            errorj = H5A_GetFormatSize(dataBaseID, n)
            if (.not. H5A_IS_ERROR(errorj)) then
                allocate(cchars(n))
                allocate(character(len=n) :: fileFormat)
                errorj = H5A_GetFormat(dataBaseID, cchars)
                if (.not. H5A_IS_ERROR(errorj)) then
                    do i = 1, n
                        fileFormat(i:i) = cchars(i)
                        ! Replace any newline or null characters with whitespace so that they may be trimmed away (kind of hacky)
                        if (cchars(i) == new_line(cchars) .or. cchars(i) == c_null_char) then
                            fileFormat(i:i) = ' '
                        end if
                    end do
                    if (trim(fileFormat) /= 'simos_r0') then
                        error_message = "Cannot read file with format '" // fileFormat // "', " //       &
                                        "only 'simos_r0' is supported. Error during read of file " // fileName%toChars()
                        call throw(io_exception(error_message))
                        goto 8000
                    end if
                end if
            end if
        end if
        groupID = H5A_CreateEntity(dataBaseID, name%to_c_chars())
        if (H5A_IS_ERROR(groupID)) then
            error_message = 'Failed to create entity ' + name + ' in file ' + filename
            call throw(io_exception(error_message))
            return
        end if
        call this%save_hdf5(groupID)
        errorj=H5A_CloseEntity(groupID)

        ! Close the data base
        8000 continue
        errorj = H5A_CloseDatabase(dataBaseID)
        if (H5A_IS_ERROR(groupID)) then
            error_message = 'Failed to close file ' + filename
            call throw(io_exception(error_message))
            return
        end if
    end subroutine

    !---------------------------------------------------------------------------

    subroutine save_hdf5_group_id(this,groupIndex)
        implicit none
        class({{type.type}}) :: this
        integer, intent(in) :: groupIndex
        ! Internal variables
        integer :: errorj
        type(string) :: error_message
        type(string) :: str
        {%-for init in type.hdf5.save.inits %}
        {{init}}
        {%-endfor %}

        ! Some initializations
        errorj=0

        ! Save the class of the object
        errorj=h5a_setType(groupIndex,'{{type.path}}' // c_null_char)
        if (H5A_IS_ERROR(errorj)) then
            error_message = 'Error during saving of {{type.path}}'
            call throw(io_exception(error_message))
            return
        end if

        {%-for attr in type.hdf5.attributes %}
        !-------------------------------------------------------------------------
        ! Save property {{attr.name}}
        !-------------------------------------------------------------------------
        {%-if attr.save.get("optional_statement")%}
        if ({{attr.save.optional_statement}}) then
            {%-for line in attr.save.body %}
            {{line}}
            {%-endfor %}
        end if
        {%-else%}
        {%-for line in attr.save.body %}
        {{line}}
        {%-endfor %}
        {%-endif%}
        {%-endfor %}

        ! Set properties order
        {{type.hdf5.save.order}}

        if (H5A_IS_ERROR(errorj)) then
            error_message = 'Error during saving to hdf5 file'
            call throw(io_exception(error_message))
            return
        end if
    end subroutine

    !-----------------------------  Load  --------------------------------------
    subroutine load_HDF5_fromDefaultFile(this)
        implicit none
        class({{type.type}}) :: this
        !Internal variables, for proper cloning
        type(String) :: fileName
        type(String) :: name

        {%if type.has_name-%}
        name = this%name   !has to be cloned before loading
	    {%-endif%}
        fileName = name%toChars()+'.h5'
        call this%load_HDF5(fileName, name)
    end subroutine load_HDF5_fromDefaultFile

    !---------------------------------------------------------------------------

    subroutine load_HDF5_fromFileNameAndEntityName(this, fileName, entityName)
        implicit none
        class({{type.type}}) :: this
        type(String), intent(in) :: fileName
        type(String), intent(in) :: entityName
        ! Internal variables
        logical :: there
        type(string) :: error_message
        integer :: dataBaseID, groupID, error
        integer :: i
        integer :: n
        character(kind=c_char), allocatable :: cchars(:)
        character(len=:), allocatable :: fileFormat

        ! Initialization
        call h5a_initialize('no config required')

        ! Open database file if present
        inquire(file=fileName%toChars(), exist=there)
        if (there) then
            call this%destroy()
            dataBaseID = H5A_OpenDatabaseReadOnly(fileName%toChars() // c_null_char)
            if (H5A_IS_ERROR(dataBaseID)) then
                error_message = 'Unable to open file ' // fileName%toChars() // ' for reading'
                call throw(io_exception(error_message))
                return
            end if
        else
            error_message = 'HDF5 file not found: ' // fileName%toChars()
            call throw(io_exception(error_message))
            return
        end if

        ! Check format attribute
        error = H5A_GetFormatSize(dataBaseID, n)
        if (.not. H5A_IS_ERROR(error)) then
            allocate(cchars(n))
            allocate(character(len=n) :: fileFormat)
            error = H5A_GetFormat(dataBaseID, cchars)
            if (.not. H5A_IS_ERROR(error)) then
                do i = 1, n
                    fileFormat(i:i) = cchars(i)
                    ! Replace any newline or null characters with whitespace so that they may be trimmed away (kind of hacky)
                    if (cchars(i) == new_line(cchars) .or. cchars(i) == c_null_char) then
                        fileFormat(i:i) = ' '
                    end if
                end do
                if (trim(fileFormat) /= 'simos_r0') then
                    error_message = "Cannot read file with format '" // fileFormat // "', " //       &
                                    "only 'simos_r0' is supported. Error during read of file " // fileName%toChars()
                    call throw(io_exception(error_message))
                    goto 8000
                end if
            end if
        end if
        if (H5A_IS_ERROR(error)) then
            error_message = 'Error determining format of file ' // fileName%toChars()
            call throw(io_exception(error_message))
            goto 8000
        end if

        ! Get the first groupIndex and load the object
        groupID = H5A_OpenEntity(dataBaseID, entityName%toChars() // c_null_char)
        {%if type.has_name-%}
        this%name = entityName
	    {%-endif%}
        if (.not. H5A_IS_ERROR(groupID)) then
            call this%load_HDF5(groupID)
            error=H5A_CloseEntity(groupID)
            if (exception_occurred()) goto 8000
        else
            error_message = 'Group not found: ' // entityName%toChars()
            call throw(io_exception(error_message))
            goto 8000
        end if

        ! Finally - close the database
        8000 continue
        error = H5A_CloseDatabase(dataBaseID)
        ! Silently ignore any error during close
    end subroutine load_HDF5_fromFileNameAndEntityName

    !---------------------------------------------------------------------------

    subroutine load_HDF5_fromGroupIndex(this, groupIndex)
        implicit none
        class({{type.type}}) :: this
        integer, intent(in) :: groupIndex
        ! Internal variables
        type(string) :: error_message
        integer :: error
        {%-for init in type.hdf5.load.inits %}
        {{init}}
        {%-endfor %}

        ! Some initializations
        error=0

        {%for attr in type.hdf5.attributes %}
        !-------------------------------------------------------------------------
        ! Load property {{attr.name}}
        !-------------------------------------------------------------------------
        {{attr.load}}
        {%endfor %}

    end subroutine load_HDF5_fromGroupIndex

    !-------------------------------Is valid -----------------------------------
    logical elemental function isValid(this)
        class({{type.type}}), intent(in) :: this
        isValid = .true.
        {%-if type.has_name%}
        if (this%name%isEmpty()) isValid = .false.
	    {%-endif%}
        {%-for attr in type.attributes if not attr.is_primitive %}
        {%-if not attr.is_optional%}
            {%-if attr.is_array%}
                {%-if attr.is_allocatable%}
        if(allocated(this%{{attr.fieldname}})) then
            if(.not. all(this%{{attr.fieldname}}%isValid())) isValid = .false.
        end if
                {%-else%}
        if(.not. all(this%{{attr.fieldname}}%isValid())) isValid = .false.
                {%-endif%}
            {%-else%}
        if(.not. this%{{attr.fieldname}}%isValid()) isValid = .false.
	        {%-endif%}
        {%-else%}
            {%-if attr.is_array%}
                {%-if attr.is_allocatable%}
        if(allocated(this%{{attr.fieldname}})) then
            if((.not. all(this%{{attr.fieldname}}%isValid())).and.(this%is_set_{{attr.fieldname}})) isValid = .false.
        end if
                {%-else%}
        if((.not. all(this%{{attr.fieldname}}%isValid())).and.(this%is_set_{{attr.fieldname}})) isValid = .false.
                {%-endif%}
            {%-else%}
        if((.not. this%{{attr.fieldname}}%isValid()).and.(this%is_set_{{attr.fieldname}})) isValid = .false.
	        {%-endif%}
	    {%-endif%}
        {%-endfor%}
    end function
    !-------------------------------Resize functions----------------------------
    {%-for attr in type.resize.attributes%}
    !---------------------------------------------------------------------------
    subroutine resize_{{attr.name}}(this, {{attr.dimension_names}})
        class({{type.name}}) :: this
        integer,intent(in) :: {{attr.dimension_names}}
        !internal variables
        integer :: error, sv
        type(string) :: error_message
        {%-if attr.has_name%}
        type(String) :: name
        integer :: idx1
        {%-endif%}
        call this%destroy_{{attr.name}}()
        if (allocated(this%{{attr.name}})) deallocate(this%{{attr.name}})
        allocate(this%{{attr.name}}({{attr.dimension_names}}),stat=sv)
        if (sv.ne.0) then
            error=-1
            error_message = 'Error during resizing in {{type.name}}, error when trying to alloc&
                &ate memory for {{attr.name}}'
            call throw(illegal_state_exception(error_message%toChars()))
            return
        end if
        {%-if attr.has_name%}
        do idx1 = 1,size(this%{{attr.name}}, 1)
            name = '{{attr.name}}' + String("_") + to_string(idx1)
            call this%{{attr.name}}(idx1)%default_init(name%toChars())
        end do
        {%-endif%}
    end subroutine resize_{{attr.name}}
    {%-endfor%}

!@@@@@ USER DEFINED PROCEDURES START @@@@@
{{type.user_defined.get("procedures", "")}}
!@@@@@ USER DEFINED PROCEDURES END @@@@@

end module {{type.module}}